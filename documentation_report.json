{
  "architectural_summary": "The project uses a Factory pattern (ProblemFactory) to instantiate Problem objects based on ID. A central ProblemSolver driver handles execution and benchmarking (ProblemSolver, BenchmarkRunner). Utilities like caching (MemoryEfficientCache) and mathematics (Library) are decoupled.",
  "source_code": [
    {
      "filename": "Program.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// The main entry point for the Project Euler solver application.\n/// </summary>\ninternal static class Program {\n    private static readonly Dictionary<string, (string Description, Action Action)> MenuActions =\n        new(StringComparer.OrdinalIgnoreCase) {\n            { \"a\", (\"solve all problems\", ProblemSolver.FullBenchmark) },\n            { \"t\", (\"verify all known solutions\", SolutionVerifier.VerifyAllKnownSolutions) }\n        };\n\n    /// <summary>\n    /// The application entry point.\n    /// </summary>\n    public static void Main() {\n        RunInteractionLoop();\n    }\n\n    /// <summary>\n    /// Runs the main interaction loop, displaying the menu and handling user input.\n    /// </summary>\n    private static void RunInteractionLoop() {\n        do {\n            PrintMenu();\n            string input = InputHandler.GetMenuSelection();\n            HandleMenuSelection(input);\n        } while (InputHandler.ShouldRunAgain());\n    }\n\n    /// <summary>\n    /// Prints the main menu to the console.\n    /// </summary>\n    private static void PrintMenu() {\n        Console.Clear();\n        Library.FunPrint(\"Project Euler Solver\");\n        Console.WriteLine();\n        foreach ((string key, (string description, _)) in MenuActions)\n            Library.FunPrint($\"Enter '{key}' to {description}.\");\n\n        Library.FunPrint($\"Enter Problem to solve (1 - {ProblemFactory.SolvedProblems()}): \");\n    }\n\n    /// <summary>\n    /// Handles the user's menu selection.\n    /// </summary>\n    /// <param name=\"input\">The user's input string.</param>\n    private static void HandleMenuSelection(string input) {\n        if (MenuActions.TryGetValue(input, out var action))\n            action.Action.Invoke();\n        else\n            ProblemSolver.IndividualBenchmark(input);\n    }\n}\n"
    },
    {
      "filename": "ProblemSolver.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "using System.Collections.Concurrent;\nusing System.Diagnostics;\n\n// ReSharper disable RedundantAssignment\nnamespace Project_Euler;\n\n/// <summary>\n/// Provides functionality to solve and benchmark Project Euler problems.\n/// Handles execution of individual problems or full suites, collecting timing data and results.\n/// </summary>\npublic static class ProblemSolver {\n    /// <summary>\n    /// The number of times to run each problem during a full benchmark to calculate average time.\n    /// </summary>\n    private const int BenchmarkRuns = 100;\n\n    /// <summary>\n    /// Solves and benchmarks a single problem specified by its ID (as a string).\n    /// </summary>\n    /// <param name=\"problem\">The problem ID string (e.g., \"1\" or \"001\").</param>\n    public static void IndividualBenchmark(string problem) {\n        int n = Convert.ToInt32(problem);\n        var data = Run(n, 1);\n        Library.FunPrint($\"Problem {n}: {data.Result}\");\n        Library.FunPrint($\"Solved in {data.Times[0]:F3} ms\");\n    }\n\n    /// <summary>\n    /// Runs a full benchmark of all registered problems.\n    /// Executes problems in parallel, collects performance metrics, and generates a report.\n    /// </summary>\n    public static void FullBenchmark() {\n        int problemCount = ProblemFactory.SolvedProblems();\n        var testData = new BenchmarkData();\n        var bag = new ConcurrentBag<ProblemData>();\n        var range = Enumerable.Range(1, problemCount);\n\n        int completedTasks = 0;\n        var progressThread = new Thread(() =>\n            DisplayProgressBar(() => completedTasks, problemCount));\n\n        var watch = Stopwatch.StartNew();\n        progressThread.Start();\n        Parallel.ForEach(range, i => {\n            bag.Add(Run(i, BenchmarkRuns));\n            Interlocked.Increment(ref completedTasks);\n        });\n\n        progressThread.Join();\n        var results = bag.OrderBy(p => p.Index).ToList();\n\n        watch.Stop();\n\n        testData.TotalTime = watch.Elapsed.TotalMilliseconds;\n\n        if (results.Any()) {\n            var slowestProblemData = results\n                .Select(p => new { Problem = p, AvgTime = p.Times.Any() ? p.Times.Average() : 0 })\n                .OrderByDescending(x => x.AvgTime)\n                .FirstOrDefault();\n\n            if (slowestProblemData != null) {\n                testData.SlowestProblem = slowestProblemData.Problem.Index;\n                testData.SlowestTime = slowestProblemData.AvgTime;\n            } else {\n                // This case should ideally not be hit if results.Any() is true and all problems have data,\n                // but it's a safeguard.\n                testData.SlowestTime = 0;\n                testData.SlowestProblem = 0;\n            }\n        } else {\n            testData.SlowestTime = 0;\n            testData.SlowestProblem = 0;\n        }\n\n        OutputHandler.GenerateFullReport(results, testData);\n        Library.FunPrint($\"Results output to {OutputHandler.LogFile}, {watch.ElapsedMilliseconds} ms total\");\n    }\n\n    /// <summary>\n    /// Runs a specific problem a specified number of times and collects timing data.\n    /// </summary>\n    /// <param name=\"n\">The ID of the problem to run.</param>\n    /// <param name=\"runs\">The number of times to execute the problem's solution.</param>\n    /// <returns>A <see cref=\"ProblemData\"/> object containing the result and execution times.</returns>\n    private static ProblemData Run(int n, int runs) {\n        var data = new ProblemData(n, runs);\n        var problem = ProblemFactory.CreateProblem(n);\n\n        for (int i = 0; i < runs; i++) {\n            var watch = Stopwatch.StartNew();\n\n            object result = problem.Solve();\n            watch.Stop();\n\n            if (i == 0) data.Result = result?.ToString() ?? string.Empty; // Handle if result itself is null\n            data.Times.Add(watch.Elapsed.TotalMilliseconds);\n        }\n\n        return data;\n    }\n\n    /// <summary>\n    /// Displays a progress bar in the console to track the completion of the benchmark.\n    /// </summary>\n    /// <param name=\"completedFunc\">A function that returns the number of completed tasks.</param>\n    /// <param name=\"total\">The total number of tasks to complete.</param>\n    private static void DisplayProgressBar(Func<int> completedFunc, int total) {\n        const int width = 50;\n        const int updateInterval = 10;\n        while (true) {\n            int completed = completedFunc();\n            double percent = (double)completed / total;\n            int filled = (int)(percent * width);\n            string bar = new string('\u2588', filled) + new string('\u2591', width - filled);\n\n            Console.SetCursorPosition(0, Console.CursorTop);\n            Console.Write($\"[{bar}] {percent * 100:F1}%\");\n\n            if (completed >= total) {\n                Console.WriteLine();\n                break;\n            }\n\n            Thread.Sleep(updateInterval);\n        }\n    }\n\n}\n\n/// <summary>\n/// Represents the data collected from running a problem, including its index, result, and execution times.\n/// </summary>\npublic class ProblemData(int index, int runs) {\n    /// <summary>\n    /// The problem number/index.\n    /// </summary>\n    public readonly int Index = index;\n    /// <summary>\n    /// A list of execution times in milliseconds for each run.\n    /// </summary>\n    public readonly List<double> Times = new(runs);\n    /// <summary>\n    /// The string representation of the solution result.\n    /// </summary>\n    public string Result = \"\";\n\n    /// <summary>\n    /// Calculated average execution time.\n    /// </summary>\n    public double AverageTime => Times.Any() ? Times.Average() : 0.0;\n    /// <summary>\n    /// Minimum execution time recorded.\n    /// </summary>\n    public double MinTime => Times.Any() ? Times.Min() : 0.0;\n    /// <summary>\n    /// Maximum execution time recorded.\n    /// </summary>\n    public double MaxTime => Times.Any() ? Times.Max() : 0.0;\n}\n\n/// <summary>\n/// Aggregates global benchmark statistics, such as the total time and the slowest problem.\n/// </summary>\npublic class BenchmarkData {\n    /// <summary>\n    /// The index of the problem that took the longest to solve (on average).\n    /// </summary>\n    public int SlowestProblem;\n    /// <summary>\n    /// The average time of the slowest problem in milliseconds.\n    /// </summary>\n    public double SlowestTime = double.MinValue;\n    /// <summary>\n    /// The total wall-clock time taken for the full benchmark suite.\n    /// </summary>\n    public double TotalTime;\n}\n"
    },
    {
      "filename": "ProblemFactory.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "using System.Diagnostics;\nusing static System.Reflection.Assembly;\n\nnamespace Project_Euler;\n\n/// <summary>\n/// A factory class responsible for registering and creating instances of <see cref=\"Problem\"/> classes.\n/// </summary>\npublic static class ProblemFactory {\n    /// <summary>\n    /// Maximum problem ID to include. Problems with IDs >= MaxProblemId are excluded \n    /// (e.g., Problem999 and similar test problems).\n    /// </summary>\n    private const int MaxProblemId = 900;\n    \n    private static readonly Dictionary<int, Type> ProblemTypes = new();\n    private static readonly Dictionary<int, Func<Problem>> ProblemFactories = new();\n    private static bool _isInitialized = false;\n\n    /// <summary>\n    /// Static constructor to initialize the problem registry.\n    /// </summary>\n    static ProblemFactory() {\n        InitializeProblemRegistry();\n    }\n\n    /// <summary>\n    /// Initializes the problem registry by explicitly registering all known problem classes.\n    /// </summary>\n    private static void InitializeProblemRegistry()\n    {\n        if (_isInitialized) return;\n\n        // Register all problems explicitly for better performance and type safety\n        RegisterProblem<Problem001>();\n        RegisterProblem<Problem002>();\n        RegisterProblem<Problem003>();\n        RegisterProblem<Problem004>();\n        RegisterProblem<Problem005>();\n        RegisterProblem<Problem006>();\n        RegisterProblem<Problem007>();\n        RegisterProblem<Problem008>();\n        RegisterProblem<Problem009>();\n        RegisterProblem<Problem010>();\n        RegisterProblem<Problem011>();\n        RegisterProblem<Problem012>();\n        RegisterProblem<Problem013>();\n        RegisterProblem<Problem014>();\n        RegisterProblem<Problem015>();\n        RegisterProblem<Problem016>();\n        RegisterProblem<Problem017>();\n        RegisterProblem<Problem018>();\n        RegisterProblem<Problem019>();\n        RegisterProblem<Problem020>();\n        RegisterProblem<Problem021>();\n        RegisterProblem<Problem022>();\n        RegisterProblem<Problem023>();\n        RegisterProblem<Problem024>();\n        RegisterProblem<Problem025>();\n        RegisterProblem<Problem026>();\n        RegisterProblem<Problem027>();\n        RegisterProblem<Problem028>();\n        RegisterProblem<Problem029>();\n        RegisterProblem<Problem030>();\n        RegisterProblem<Problem031>();\n        RegisterProblem<Problem032>();\n        RegisterProblem<Problem033>();\n        RegisterProblem<Problem034>();\n        RegisterProblem<Problem035>();\n        RegisterProblem<Problem036>();\n        RegisterProblem<Problem037>();\n        RegisterProblem<Problem038>();\n        RegisterProblem<Problem039>();\n        RegisterProblem<Problem040>();\n        RegisterProblem<Problem041>();\n        RegisterProblem<Problem042>();\n        RegisterProblem<Problem043>();\n        RegisterProblem<Problem044>();\n        RegisterProblem<Problem045>();\n        RegisterProblem<Problem046>();\n        RegisterProblem<Problem047>();\n        RegisterProblem<Problem048>();\n        RegisterProblem<Problem049>();\n        RegisterProblem<Problem050>();\n\n        _isInitialized = true;\n    }\n\n    /// <summary>\n    /// Registers a specific problem class into the factory.\n    /// </summary>\n    /// <typeparam name=\"T\">The type of the problem class.</typeparam>\n    private static void RegisterProblem<T>() where T : Problem, new()\n    {\n        var problem = new T();\n        int? problemId = ExtractProblemId(typeof(T).Name);\n        \n        if (problemId.HasValue && problemId.Value < MaxProblemId)\n        {\n            ProblemTypes[problemId.Value] = typeof(T);\n            ProblemFactories[problemId.Value] = () => new T();\n        }\n    }\n\n    /// <summary>\n    /// Creates an instance of the problem with the specified ID.\n    /// </summary>\n    /// <param name=\"id\">The ID of the problem to create.</param>\n    /// <returns>An instance of the requested <see cref=\"Problem\"/>.</returns>\n    /// <exception cref=\"ArgumentOutOfRangeException\">Thrown if the problem with the specified ID is not found.</exception>\n    public static Problem CreateProblem(int id) {\n        if (ProblemFactories.TryGetValue(id, out var factory)) {\n            return factory();\n        }\n\n        throw new ArgumentOutOfRangeException(nameof(id), $\"Problem with ID {id} not found.\");\n    }\n\n    /// <summary>\n    /// Gets the count of currently registered (solved) problems.\n    /// </summary>\n    /// <returns>The number of solved problems.</returns>\n    public static int SolvedProblems() {\n        return ProblemTypes.Count;\n    }\n\n    /// <summary>\n    /// Extracts the problem ID from the class name.\n    /// </summary>\n    /// <param name=\"typeName\">The name of the class (e.g., \"Problem001\").</param>\n    /// <returns>The problem ID as an integer, or null if invalid.</returns>\n    private static int? ExtractProblemId(string typeName) {\n        if (typeName.StartsWith(\"Problem\") && int.TryParse(typeName.AsSpan(7), out int id)) return id;\n\n        return null;\n    }\n}\n"
    },
    {
      "filename": "Library.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "using System.Collections;\nusing System.Numerics;\n\n// ReSharper disable UnusedMember.Global\n\nnamespace Project_Euler;\n\n/// <summary>\n/// A utility class containing common mathematical functions and helpers used across multiple Project Euler problems.\n/// Includes functions for number theory, combinatorics, figurate numbers, and general file I/O.\n/// </summary>\npublic static class Library {\n    /// <summary>\n    /// The maximum exponent for base 10 that results in an integer which fits within a standard 32-bit signed integer (Int32).\n    /// 10^9 = 1,000,000,000 (fits in Int32). 10^10 = 10,000,000,000 (overflows Int32).\n    /// </summary>\n    private const int MaxSafeIntPow10Exponent = 9;\n\n    //Program-wide tasks.\n    /// <summary>\n    /// Prints a string to the console, character by character, with an optional delay.\n    /// Used for stylized output in the console application.\n    /// </summary>\n    /// <param name=\"s\">The string to print.</param>\n    /// <param name=\"enableDelay\">If true, a small delay (10ms) is introduced after printing each character to simulate typing.</param>\n    public static void FunPrint(string s, bool enableDelay = false) {\n        const int wait = 10;\n        foreach (char c in s) {\n            Console.Write(c);\n            if (enableDelay) {\n                Thread.Sleep(wait);\n            }\n        }\n\n        Console.WriteLine();\n    }\n\n    /// <summary>\n    /// Reads all lines from a file, splits them by commas, trims whitespace, and removes quotation marks.\n    /// Primarily designed for Project Euler data files like 'names.txt' or 'words.txt' which are often comma-delimited strings.\n    /// </summary>\n    /// <param name=\"fileName\">The name of the file to read. The file is expected to be in the application's base directory.</param>\n    /// <returns>A list of strings extracted and processed from the file. Returns an empty list if the file is empty or lines produce no data after processing.</returns>\n    /// <exception cref=\"System.IO.IOException\">Thrown when an I/O error occurs (e.g., file not found, permission issues).</exception>\n    public static List<string> ReadFile(string fileName) {\n        string filePath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, fileName);\n        List<string> data = File.ReadLines(filePath)\n                                .SelectMany(line => line.Split(','))\n                                .Select(s => s.Trim().Replace(\"\\\"\", \"\"))\n                                .ToList();\n        return data;\n    }\n\n    //Maths tasks.\n\n    /// <summary>\n    /// Calculates the sum of the decimal digits of a BigInteger.\n    /// Optimized using BigInteger.DivRem for better performance on large numbers compared to separate division and modulus operations.\n    /// </summary>\n    /// <param name=\"digits\">The BigInteger whose digits are to be summed.</param>\n    /// <returns>The sum of the digits as an integer.</returns>\n    public static int SumDigits(BigInteger digits) {\n        if (digits < 0) {\n            digits = BigInteger.Abs(digits);\n        }\n\n        int sum = 0;\n        while (digits != 0) {\n            // Use DivRem for better performance - single operation instead of separate % and /\n            digits = BigInteger.DivRem(digits, 10, out BigInteger remainder);\n            sum += (int)remainder;\n        }\n\n        return sum;\n    }\n\n    /// <summary>\n    /// Calculates the Greatest Common Divisor (GCD) of two integers using the Euclidean algorithm.\n    /// Time Complexity: O(log(min(a, b))) - very efficient for all practical inputs.\n    /// </summary>\n    /// <param name=\"a\">The first integer.</param>\n    /// <param name=\"b\">The second integer.</param>\n    /// <returns>The GCD of a and b. The result is always non-negative.</returns>\n    /// <remarks>\n    /// If one of the inputs is Int32.MinValue, the result might be Int32.MinValue because its absolute value cannot be represented as a positive Int32.\n    /// </remarks>\n    public static int Gcd(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        // By convention, GCD is non-negative.\n        // If 'a' is int.MinValue, Math.Abs(a) would throw. This happens if inputs\n        // like (int.MinValue, 0) or (int.MinValue, int.MinValue) are given.\n        // The positive GCD, in this case, is 2^31, unrepresentable as a positive int.\n        // Returning int.MinValue is a way to signal this or adhere to a convention\n        // where the result retains the sign of 'a' from the algorithm if it's int.MinValue.\n        if (a == int.MinValue) {\n            return int.MinValue;\n        }\n        return Math.Abs(a);\n    }\n\n    /// <summary>\n    /// Calculates the factorial of a non-negative integer using BigInteger to handle large results.\n    /// Optimized with early returns for small values and leverages IntFactorial for efficiency.\n    /// </summary>\n    /// <param name=\"n\">The non-negative integer for which to calculate the factorial.</param>\n    /// <returns>The factorial of n as a BigInteger. Returns 1 for n=0 or n=1.</returns>\n    /// <exception cref=\"System.ArgumentOutOfRangeException\">Thrown if n is negative.</exception>\n    public static BigInteger Factorial(int n) {\n        if (n < 0) throw new ArgumentOutOfRangeException(nameof(n), \"Factorial is not defined for negative numbers.\");\n        \n        // Use optimized int factorial for small values\n        if (n <= 12) return IntFactorial(n);\n        \n        // For larger values, start from the largest precomputed value\n        BigInteger factorial = FactorialLookup[12]; // 12! = 479001600\n        for (int i = 13; i <= n; i++) factorial *= i;\n        return factorial;\n    }\n\n    /// <summary>\n    /// Pre-computed factorial values for n=0 to n=12 for optimal performance.\n    /// Used by both IntFactorial and Factorial methods.\n    /// </summary>\n    private static readonly int[] FactorialLookup = {\n        1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600\n    };\n\n    /// <summary>\n    /// Calculates the factorial of a non-negative integer. Result is an int.\n    /// This method is limited to small inputs (n &lt;= 12) due to int overflow.\n    /// For larger inputs, use Factorial(int n) which returns BigInteger.\n    /// Optimized with pre-computed lookup table for maximum performance.\n    /// </summary>\n    /// <param name=\"n\">The non-negative integer. Must be &lt;= 12.</param>\n    /// <returns>The factorial of n as an int. Returns 1 for n=0 or n=1.</returns>\n    /// <exception cref=\"System.ArgumentOutOfRangeException\">Thrown if n is negative or &gt; 12.</exception>\n    public static int IntFactorial(int n) {\n        if (n < 0) throw new ArgumentOutOfRangeException(nameof(n), \"Factorial is not defined for negative numbers.\");\n        if (n > 12) {\n            throw new ArgumentOutOfRangeException(nameof(n), \"Input too large for int factorial, use BigInteger Factorial(int n) instead.\");\n        }\n        return FactorialLookup[n];\n    }\n\n    /// <summary>\n    /// Pre-computed powers of 10 for exponents 0-9 for optimal performance.\n    /// </summary>\n    private static readonly int[] Pow10Lookup = {\n        1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000\n    };\n\n    /// <summary>\n    /// Calculates 10 raised to the power of a non-negative exponent.\n    /// Optimized with pre-computed lookup table for exponents 0-9.\n    /// </summary>\n    /// <param name=\"exp\">The non-negative exponent.</param>\n    /// <returns>10 to the power of exp as an int.</returns>\n    /// <exception cref=\"System.ArgumentOutOfRangeException\">Thrown if exp is negative.</exception>\n    /// <exception cref=\"System.OverflowException\">Thrown if 10^exp would overflow Int32 (i.e., exp > 9).</exception>\n    public static int Pow10(int exp) {\n        if (exp < 0) {\n            throw new ArgumentOutOfRangeException(nameof(exp), \"Exponent must be non-negative.\");\n        }\n        if (exp > MaxSafeIntPow10Exponent) { // MaxSafeIntPow10Exponent would be 9\n            throw new OverflowException($\"Cannot calculate 10^{exp} as it would overflow Int32. Maximum safe exponent is {MaxSafeIntPow10Exponent}.\");\n        }\n\n        return Pow10Lookup[exp];\n    }\n\n    /// <summary>\n    /// Counts the number of decimal digits in an integer.\n    /// Handles negative numbers by counting digits in their absolute value.\n    /// </summary>\n    /// <param name=\"n\">The integer to count digits for.</param>\n    /// <returns>The number of decimal digits in n. Returns 1 for n=0.</returns>\n    public static int DigitCount(int n) {\n        if (n == 0) {\n            return 1;\n        }\n\n        if (n == int.MinValue) {\n            return 10; // int.MinValue (-2,147,483,648) has 10 digits.\n        }\n\n        if (n < 0) {\n            n = Math.Abs(n); // Safe now as int.MinValue is handled.\n        }\n\n        int count = 0;\n        // Loop for positive numbers\n        while (n > 0) {\n            count++;\n            n /= 10;\n        }\n        return count;\n    }\n\n    /// <summary>\n    /// Calculates the list of all positive divisors of a given number.\n    /// Time Complexity: O(\u221an) - optimal algorithm for divisor generation.\n    /// Space Complexity: O(d(n)) where d(n) is the number of divisors.\n    /// </summary>\n    /// <param name=\"n\">The number for which to find divisors. Must be positive.</param>\n    /// <returns>A list of long integers representing all positive divisors of n, sorted in ascending order. Returns {1} if n is 1.</returns>\n    /// <exception cref=\"System.ArgumentOutOfRangeException\">Thrown if n is less than or equal to 0.</exception>\n    public static List<long> GetDivisors(long n) {\n        if (n <= 0) {\n            throw new ArgumentOutOfRangeException(nameof(n), \"Input number must be positive.\");\n        }\n        if (n == 1) {\n            return new List<long> { 1 };\n        }\n\n        var smallDivisors = new List<long>();\n        var largeDivisors = new List<long>();\n\n        for (long i = 1; i * i <= n; i++) {\n            if (n % i == 0) {\n                smallDivisors.Add(i);\n                if (i * i != n) {\n                    largeDivisors.Add(n / i);\n                }\n            }\n        }\n\n        for (int i = largeDivisors.Count - 1; i >= 0; i--) {\n            smallDivisors.Add(largeDivisors[i]);\n        }\n\n        return smallDivisors;\n    }\n\n    /// <summary>\n    /// Calculates Euler's Totient function (phi function) for a given positive integer n.\n    /// \u03c6(n) counts the number of positive integers up to n that are relatively prime to n.\n    /// </summary>\n    /// <param name=\"n\">A positive integer.</param>\n    /// <returns>The value of Euler's Totient function \u03c6(n).</returns>\n    /// <exception cref=\"System.ArgumentOutOfRangeException\">Thrown if n is less than or equal to 0.</exception>\n    public static long EulerPhi(long n) {\n        if (n <= 0) {\n            throw new ArgumentOutOfRangeException(nameof(n), \"Input number must be positive.\");\n        }\n\n        long result = n;\n        long tempN = n;\n\n        // Handle the factor 2 separately\n        if (tempN % 2 == 0) {\n            result -= result / 2; // Apply (1 - 1/2) factor\n            while (tempN % 2 == 0) {\n                tempN /= 2; // Remove all factors of 2 from tempN\n            }\n        }\n\n        // Iterate for odd factors p, starting from 3\n        for (long p = 3; p * p <= tempN; p += 2) {\n            if (tempN % p == 0) { // If p is a prime factor\n                result -= result / p; // Apply (1 - 1/p) factor\n                while (tempN % p == 0) {\n                    tempN /= p; // Remove all factors of p from tempN\n                }\n            }\n        }\n\n        if (tempN > 1) { // Remaining tempN is a prime factor\n            result -= result / tempN; // Apply (1 - 1/tempN) factor\n        }\n\n        return result;\n    }\n\n    /// <summary>\n    /// Performs modular exponentiation (baseVal^exponent) % modulus.\n    /// Efficiently calculates large powers modulo a number.\n    /// </summary>\n    /// <param name=\"baseVal\">The base value.</param>\n    /// <param name=\"exponent\">The non-negative exponent.</param>\n    /// <param name=\"modulus\">The positive modulus.</param>\n    /// <returns>The result of (baseVal^exponent) % modulus.</returns>\n    /// <exception cref=\"System.ArgumentOutOfRangeException\">\n    /// Thrown if exponent is negative or if modulus is less than or equal to 0.\n    /// </exception>\n    public static BigInteger ModPow(BigInteger baseVal, BigInteger exponent, BigInteger modulus) {\n        if (modulus <= 0) {\n            throw new ArgumentOutOfRangeException(nameof(modulus), \"Modulus must be positive.\");\n        }\n        if (exponent < 0) {\n            throw new ArgumentOutOfRangeException(nameof(exponent), \"Exponent must be non-negative.\");\n        }\n\n        BigInteger res = 1;\n        baseVal %= modulus; // Ensure baseVal is within modulus range\n\n        while (exponent > 0) {\n            if (exponent % 2 == 1) { // If exponent is odd\n                res = (res * baseVal) % modulus;\n            }\n            exponent >>= 1; // exponent /= 2\n            baseVal = (baseVal * baseVal) % modulus; // Square the base\n        }\n        return res;\n    }\n\n    /// <summary>\n    /// Calculates the integer square root of a non-negative BigInteger (i.e., floor(sqrt(n))).\n    /// Uses Newton's method (Babylonian method) for approximation.\n    /// </summary>\n    /// <param name=\"n\">The non-negative BigInteger for which to find the integer square root.</param>\n    /// <returns>The integer square root of n.</returns>\n    /// <exception cref=\"System.ArgumentOutOfRangeException\">Thrown if n is negative.</exception>\n    public static BigInteger IntegerSquareRoot(BigInteger n) {\n        if (n < 0) {\n            throw new ArgumentOutOfRangeException(nameof(n), \"Cannot calculate square root of a negative number.\");\n        }\n        if (n == 0) {\n            return 0;\n        }\n\n        // Improved initial guess using bit length for faster convergence.\n        // (n.GetBitLength() + 1) / 2 effectively calculates ceil(bitLength / 2.0).\n        int shiftAmount = (int)((n.GetBitLength() + 1) / 2);\n        BigInteger x = BigInteger.One << shiftAmount;\n\n        // Newton's method iterations\n        BigInteger y = (x + n / x) / 2;\n\n        // Loop until y >= x. This is a standard termination for integer Newton's method.\n        while (y < x) {\n            x = y;\n            y = (x + n / x) / 2;\n        }\n\n        // After the loop, x is the smallest integer such that x >= sqrt(n).\n        if (x * x > n) {\n            return x - 1;\n        }\n        return x;\n    }\n\n    #region Combinatorics\n\n    /// <summary>\n    /// Calculates the number of combinations (nCk, \"n choose k\"), which is the number of ways \n    /// to choose k items from a set of n items without regard to the order of selection.\n    /// Uses the formula nCk = n! / (k! * (n-k)!).\n    /// </summary>\n    /// <param name=\"n\">The total number of items in the set. Must be non-negative.</param>\n    /// <param name=\"k\">The number of items to choose. Must be non-negative and not greater than n.</param>\n    /// <returns>The number of combinations (nCk) as a BigInteger. \n    /// Returns 0 if k &lt; 0 or k &gt; n.\n    /// Returns 1 if k == 0 or k == n.</returns>\n    /// <exception cref=\"System.ArgumentOutOfRangeException\">Thrown if n is negative.</exception>\n    public static BigInteger Combinations(int n, int k) {\n        if (n < 0) {\n            throw new ArgumentOutOfRangeException(nameof(n), \"Total number of items (n) must be non-negative.\");\n        }\n        if (k < 0 || k > n) {\n            return 0; // Or throw ArgumentOutOfRangeException if strictness is required for k.\n        }\n        if (k == 0 || k == n) {\n            return 1;\n        }\n        // Optimization: C(n, k) = C(n, n-k). Choose smaller k.\n        if (k > n / 2) {\n            k = n - k;\n        }\n\n        BigInteger result = 1;\n        for (int i = 1; i <= k; i++) {\n            // result = result * (n - k + i) / i; // Alternative form\n            result = result * (n - i + 1) / i; // Iterative calculation: C(n,k) = (n/1) * ((n-1)/2) * ... * ((n-k+1)/k)\n        }\n        return result;\n    }\n\n    /// <summary>\n    /// Calculates the number of partial permutations (nPk), which is the number of ways \n    /// to choose and arrange k items from a set of n items where the order of selection matters.\n    /// Uses the formula nPk = n! / (n-k)!.\n    /// </summary>\n    /// <param name=\"n\">The total number of items in the set. Must be non-negative.</param>\n    /// <param name=\"k\">The number of items to choose and arrange. Must be non-negative and not greater than n.</param>\n    /// <returns>The number of partial permutations (nPk) as a BigInteger.\n    /// Returns 0 if k &lt; 0 or k &gt; n.\n    /// Returns 1 if k == 0.</returns>\n    /// <exception cref=\"System.ArgumentOutOfRangeException\">Thrown if n is negative.</exception>\n    public static BigInteger Permutations(int n, int k) {\n        if (n < 0) {\n            throw new ArgumentOutOfRangeException(nameof(n), \"Total number of items (n) must be non-negative.\");\n        }\n        if (k < 0 || k > n) {\n            return 0; // Or throw ArgumentOutOfRangeException if strictness is required for k.\n        }\n        if (k == 0) {\n            return 1;\n        }\n\n        BigInteger result = 1;\n        for (int i = 0; i < k; i++) {\n            result *= (n - i);\n        }\n        return result;\n    }\n\n    #endregion Combinatorics\n\n    #region Figurate Number Checks\n\n    /// <summary>\n    /// Calculates the integer square root of a non-negative long integer (i.e., floor(sqrt(n))).\n    /// Uses Newton's method for refinement if needed.\n    /// </summary>\n    /// <param name=\"n\">The non-negative long integer.</param>\n    /// <returns>The integer square root of n.</returns>\n    /// <exception cref=\"System.ArgumentOutOfRangeException\">Thrown if n is negative.</exception>\n    private static long LongIntegerSquareRoot(long n) {\n        if (n < 0) throw new ArgumentOutOfRangeException(nameof(n), \"Cannot calculate square root of a negative number.\");\n        if (n == 0) return 0;\n        \n        long root;\n        // Initial guess using Math.Sqrt, then refine with Newton's method\n        // This is generally good for `long` as Math.Sqrt provides a double precision float.\n        if (n > (1L << 50)) { // Heuristic: for very large n, Math.Sqrt might be less precise\n            root = (long)IntegerSquareRoot(new BigInteger(n)); // Fallback to BigInteger version\n        } else {\n            root = (long)Math.Sqrt(n);\n        }\n\n        // Newton's method step is added for robustness\n        if (root == 0 && n > 0) root = 1;\n\n        long nextRoot = (root + n / root) / 2;\n        if (nextRoot < root) { \n             root = nextRoot;\n        }\n       \n        // Final check: the result 'root' must satisfy root*root <= n.\n        while (root * root > n) {\n            root--;\n        }\n        while ((root + 1) * (root + 1) <= n) {\n            root++;\n        }\n        return root;\n    }\n\n    /// <summary>\n    /// Checks if a number is a perfect square.\n    /// </summary>\n    /// <param name=\"number\">The number to check. Must be non-negative.</param>\n    /// <returns>True if the number is a perfect square, false otherwise.</returns>\n    /// <remarks>Returns false for negative numbers.</remarks>\n    public static bool IsSquare(long number) {\n        if (number < 0) return false;\n        if (number == 0) return true; // 0 is considered a square of 0.\n        long root = LongIntegerSquareRoot(number);\n        return root * root == number;\n    }\n\n    /// <summary>\n    /// Checks if a number is a triangular number.\n    /// Triangular numbers are generated by the formula T_k = k(k+1)/2.\n    /// </summary>\n    /// <param name=\"number\">The number to check.</param>\n    /// <returns>True if the number is triangular, false otherwise.</returns>\n    /// <remarks>Returns false for non-positive numbers as triangular numbers are typically positive (except T0=0).</remarks>\n    public static bool IsTriangular(long number) {\n        if (number < 0) return false;\n        if (number == 0) return true; // T_0 = 0.\n        // We need to solve k(k+1)/2 = number  => k^2 + k - 2*number = 0\n        // For k to be a positive integer, 1 + 8*number must be a perfect square.\n        long discriminant = 1 + 8 * number;\n        if (discriminant < 0 || !IsSquare(discriminant)) {\n            return false;\n        }\n        long m = LongIntegerSquareRoot(discriminant);\n        // k = (-1 + m) / 2. For k to be an integer, (-1+m) must be even, so m must be odd.\n        return (m > 1) && ((m - 1) % 2 == 0);\n    }\n    \n    /// <summary>\n    /// Checks if a number is a pentagonal number.\n    /// Pentagonal numbers are generated by the formula Pk = k(3k-1)/2.\n    /// </summary>\n    /// <param name=\"number\">The number to check.</param>\n    /// <returns>True if number is a pentagonal number, false otherwise.</returns>\n    /// <remarks>Returns false for non-positive numbers as pentagonal numbers are positive (P0=0, P1=1).</remarks>\n    public static bool IsPentagonal(long number) {\n        if (number < 0) return false;\n        if (number == 0) return true; // P_0 = 0. \n        // We need to solve k(3k-1)/2 = number => 3k^2 - k - 2*number = 0\n        // For k to be a positive integer, 1 + 24*number must be a perfect square.\n        long discriminant = 1 + 24 * number;\n        if (discriminant < 0 || !IsSquare(discriminant)) {\n            return false;\n        }\n        long m = LongIntegerSquareRoot(discriminant);\n        // k = (1 + m) / 6. For k to be a positive integer, (1+m) must be divisible by 6.\n        return (1 + m) % 6 == 0;\n    }\n\n    /// <summary>\n    /// Checks if a number is a hexagonal number.\n    /// Hexagonal numbers are generated by the formula Hk = k(2k-1).\n    /// </summary>\n    /// <param name=\"number\">The number to check.</param>\n    /// <returns>True if the number is hexagonal, false otherwise.</returns>\n    /// <remarks>Returns false for non-positive numbers (H0=0, H1=1).</remarks>\n    public static bool IsHexagonal(long number) {\n        if (number < 0) return false;\n        if (number == 0) return true; // H_0 = 0.\n        // We need to solve k(2k-1) = number => 2k^2 - k - number = 0\n        // For k to be a positive integer, 1 + 8*number must be a perfect square.\n        long discriminant = 1 + 8 * number;\n        if (discriminant < 0 || !IsSquare(discriminant)) {\n            return false;\n        }\n        long m = LongIntegerSquareRoot(discriminant);\n        // k = (1 + m) / 4. For k to be a positive integer, (1+m) must be divisible by 4.\n        return (1 + m) % 4 == 0;\n    }\n\n    /// <summary>\n    /// Checks if a number is a heptagonal number.\n    /// Heptagonal numbers are generated by the formula Pk,7 = k(5k-3)/2.\n    /// </summary>\n    /// <param name=\"number\">The number to check.</param>\n    /// <returns>True if the number is heptagonal, false otherwise.</returns>\n    /// <remarks>Returns false for non-positive numbers (P0,7=0, P1,7=1).</remarks>\n    public static bool IsHeptagonal(long number) {\n        if (number < 0) return false;\n        if (number == 0) return true; // P_0,7 = 0.\n        // We need to solve k(5k-3)/2 = number => 5k^2 - 3k - 2*number = 0\n        // For k to be a positive integer, 9 + 40*number must be a perfect square.\n        long discriminant = 9 + 40 * number;\n        if (discriminant < 0 || !IsSquare(discriminant)) {\n            return false;\n        }\n        long m = LongIntegerSquareRoot(discriminant);\n        // k = (3 + m) / 10. For k to be a positive integer, (3+m) must be divisible by 10.\n        return (3 + m) % 10 == 0;\n    }\n\n    /// <summary>\n    /// Checks if a number is an octagonal number.\n    /// Octagonal numbers are generated by the formula Pk,8 = k(3k-2).\n    /// </summary>\n    /// <param name=\"number\">The number to check.</param>\n    /// <returns>True if the number is octagonal, false otherwise.</returns>\n    /// <remarks>Returns false for non-positive numbers (P0,8=0, P1,8=1).</remarks>\n    public static bool IsOctagonal(long number) {\n        if (number < 0) return false;\n        if (number == 0) return true; // P_0,8 = 0.\n        // We need to solve k(3k-2) = number => 3k^2 - 2k - number = 0\n        // For k to be a positive integer, 4 + 12*number must be a perfect square.\n        long discriminant = 4 + 12 * number;\n        if (discriminant < 0 || !IsSquare(discriminant)) {\n            return false;\n        }\n        long m = LongIntegerSquareRoot(discriminant);\n        // k = (2 + m) / 6. For k to be a positive integer, (2+m) must be divisible by 6.\n        return (2 + m) % 6 == 0;\n    }\n\n    #endregion Figurate Number Checks\n\n    //Boolean Checks\n\n    /// <summary>\n    /// Checks if an integer is a palindrome.\n    /// A number is a palindrome if it reads the same forwards and backward (e.g., 121, 55, 9009).\n    /// Negative signs are ignored; the check is performed on the absolute value.\n    /// </summary>\n    /// <param name=\"n\">The integer to check.</param>\n    /// <returns>True if the absolute value of n is a palindrome, false otherwise.</returns>\n    public static bool IsPalindrome(int n) {\n        if (n == int.MinValue) return false; // Math.Abs(int.MinValue) overflows\n        int absN = Math.Abs(n);\n        int reverse = 0;\n        int temp = absN;\n        while (temp != 0) {\n            reverse = reverse * 10 + temp % 10;\n            temp /= 10;\n        }\n        return reverse == absN;\n    }\n\n    /// <summary>\n    /// Checks if a string is a palindrome.\n    /// A string is a palindrome if it reads the same forwards and backward (e.g., \"madam\", \"racecar\").\n    /// The check is case-sensitive.\n    /// </summary>\n    /// <param name=\"s\">The string to check. Can be null or empty.</param>\n    /// <returns>True if the string is a palindrome, false otherwise. Returns true for null or empty strings or single-character strings.</returns>\n    public static bool IsPalindrome(string s) {\n        if (string.IsNullOrEmpty(s) || s.Length == 1) return true;\n        for (int i = 0; i < s.Length / 2; i++)\n            if (s[i] != s[s.Length - 1 - i])\n                return false;\n\n        return true;\n    }\n\n    /// <summary>\n    /// Checks if an integer is a prime number.\n    /// A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.\n    /// Uses 6k +/- 1 optimization for efficiency.\n    /// </summary>\n    /// <param name=\"n\">The integer to check.</param>\n    /// <returns>True if n is prime, false otherwise.</returns>\n    public static bool IsPrime(int n) {\n        switch (n) {\n            case <= 1:\n                return false;\n            case 2 or 3:\n                return true;\n        }\n\n        if (n % 2 == 0) return false;\n        if (n % 3 == 0) return false;\n\n        // Check from 5 onwards, stepping by 6 (i.e., 5, 11, 17, ...)\n        // Numbers not divisible by 2 or 3 can be written as 6k \u00b1 1.\n        for (int i = 5; i * i <= n; i += 6)\n            if (n % i == 0 || n % (i + 2) == 0) // Check i and i+2 (e.g., 5 and 7)\n                return false;\n\n        return true;\n    }\n\n    /// <summary>\n    /// Checks if a string is pandigital from 1 to 9.\n    /// The string must be exactly 9 characters long and contain each digit from '1' to '9' exactly once.\n    /// </summary>\n    /// <param name=\"s\">The string to check.</param>\n    /// <returns>True if the string is 1-9 pandigital, false otherwise.</returns>\n    public static bool IsPandigital(string s) {\n        if (s.Length != 9) return false;\n        int mask = 0;\n        foreach (char c in s) {\n            if (c < '1' || c > '9') return false; // Not a digit 1-9\n            int digit = c - '0';\n            int bit = 1 << (digit - 1);\n            if ((mask & bit) != 0) return false; // Digit already seen\n            mask |= bit;\n        }\n        return mask == 0x1FF; // 0x1FF = 111111111 in binary, represents digits 1-9\n    }\n\n    /// <summary>\n    /// Checks if an integer is pandigital from 1 up to a certain number of digits (implicitly, the number of digits in n).\n    /// For example, if n is 123, it checks if it's 1-3 pandigital. If n is 2143, it checks if it's 1-4 pandigital.\n    /// Digits must be non-zero.\n    /// </summary>\n    /// <param name=\"n\">The integer to check. Must be positive.</param>\n    /// <returns>True if n is pandigital for its number of digits (e.g., a 4-digit number is 1-4 pandigital), false otherwise.\n    /// Returns false if n contains a zero digit, or if n is negative or zero.</returns>\n    public static bool IsPandigital(int n) {\n        if (n <= 0) return false;\n\n        int numDigits = 0;\n        int tempN = n;\n        int bitmask = 0;\n\n        while (tempN > 0) {\n            int digit = tempN % 10;\n            if (digit == 0) return false; // Pandigital 1-k does not include 0\n\n            int bit = 1 << (digit - 1);\n            if ((bitmask & bit) != 0) return false; // Repeated digit\n            \n            bitmask |= bit;\n            numDigits++;\n            tempN /= 10;\n        }\n\n        // Check if all digits from 1 to numDigits are present\n        // e.g., if numDigits is 3, expectedMask is (1 << 3) - 1 = 0b111\n        // e.g., if numDigits is 9, expectedMask is (1 << 9) - 1 = 0b111111111 (0x1FF)\n        int expectedMask = (1 << numDigits) - 1;\n        return bitmask == expectedMask;\n    }\n\n    //Array Operations\n\n    /// <summary>\n    /// Generates the next lexicographical permutation of the given integer array in place.\n    /// Implements Narayana Pandita's algorithm.\n    /// </summary>\n    /// <param name=\"arr\">The integer array to permute. The array is modified in place. Cannot be null.</param>\n    /// <returns>\n    /// True if a next lexicographical permutation was found and applied to the array.\n    /// False if the array was already the last permutation (e.g., sorted in descending order), \n    /// in which case the array is reversed to its first permutation (e.g., sorted in ascending order).\n    /// </returns>\n    /// <exception cref=\"System.ArgumentNullException\">Thrown if arr is null.</exception>\n    public static bool Permute(int[] arr) {\n        if (arr == null) throw new ArgumentNullException(nameof(arr));\n        int i = arr.Length - 1;\n        while (i > 0 && arr[i - 1] >= arr[i]) i--;\n        if (i <= 0) {\n            // Array is the last permutation (sorted in descending order).\n            // Reverse it to the first permutation (sorted in ascending order).\n            Array.Reverse(arr);\n            return false;\n        }\n\n        // Find the smallest element to the right of arr[i-1] that is greater than arr[i-1]\n        int j = arr.Length - 1;\n        while (arr[j] <= arr[i - 1]) j--;\n        \n        // Swap arr[i-1] and arr[j]\n        (arr[i - 1], arr[j]) = (arr[j], arr[i - 1]);\n\n        // Reverse the suffix starting at arr[i]\n        Array.Reverse(arr, i, arr.Length - i);\n        return true;\n    }\n\n    /// <summary>\n    /// Generates a boolean array indicating primality up to a specified limit using the Sieve of Eratosthenes.\n    /// Time Complexity: O(n log log n) - optimal for prime generation up to n.\n    /// Space Complexity: O(n) - uses bool array for fast access but higher memory usage.\n    /// Recommended for limits &lt; 100,000 or when frequent random access is needed.\n    /// </summary>\n    /// <param name=\"limit\">The inclusive upper bound for the sieve. Must be non-negative.</param>\n    /// <returns>A boolean array `isPrime` of size `limit + 1` where `isPrime[i]` is true if `i` is prime, and false otherwise.\n    /// Returns an array representing no primes if limit is less than 2.</returns>\n    public static bool[] SieveOfEratosthenesBoolArray(int limit) {\n        if (limit < 0) throw new ArgumentOutOfRangeException(nameof(limit), \"Limit must be non-negative.\");\n        bool[] isPrime = new bool[limit + 1];\n        if (limit < 2) return isPrime; // All false by default, which is correct for 0, 1\n\n        for (int i = 2; i <= limit; i++) isPrime[i] = true;\n\n        for (int p = 2; p * p <= limit; p++) {\n            if (isPrime[p]) {\n                for (int i = p * p; i <= limit; i += p)\n                    isPrime[i] = false;\n            }\n        }\n        return isPrime;\n    }\n\n    /// <summary>\n    /// Generates a BitArray indicating primality up to a specified limit using the Sieve of Eratosthenes.\n    /// Time Complexity: O(n log log n) - optimal for prime generation up to n.\n    /// Space Complexity: O(n/8) - uses BitArray for ~87.5% memory reduction vs bool array.\n    /// Recommended for large limits (>= 100,000) where memory efficiency is important.\n    /// </summary>\n    /// <param name=\"limit\">The inclusive upper bound for the sieve. Must be non-negative.</param>\n    /// <returns>A BitArray `isPrime` of size `limit + 1` where `isPrime[i]` is true if `i` is prime, and false otherwise.\n    /// Returns a BitArray representing no primes if limit is less than 2.</returns>\n    public static BitArray SieveOfEratosthenesBitArray(int limit) {\n        if (limit < 0) throw new ArgumentOutOfRangeException(nameof(limit), \"Limit must be non-negative.\");\n        BitArray isPrime = new BitArray(limit + 1, true); // size limit + 1 to use index limit\n\n        if (limit < 2) {\n            // Mark all as false if limit is less than 2\n            for (int k = 0; k <= limit; k++) isPrime[k] = false;\n            return isPrime;\n        }\n\n        isPrime[0] = false;\n        isPrime[1] = false;\n\n        for (int p = 2; p * p <= limit; p++) {\n            if (isPrime[p]) {\n                for (int i = p * p; i <= limit; i += p)\n                    isPrime[i] = false;\n            }\n        }\n        return isPrime;\n    }\n\n    /// <summary>\n    /// Filters a collection of numbers and returns a set containing only those that are prime.\n    /// Uses SieveOfEratosthenesBitArray internally to determine primality efficiently.\n    /// </summary>\n    /// <param name=\"numbers\">An enumerable collection of integers to check for primality.</param>\n    /// <returns>A HashSet containing all unique prime numbers from the input collection.\n    /// Numbers less than 2 are ignored.</returns>\n    public static HashSet<int> GetPrimesFromNumbers(IEnumerable<int> numbers) {\n        var distinctNumbers = numbers.Where(n => n >= 2).Distinct().ToList();\n        if (!distinctNumbers.Any()) {\n            return new HashSet<int>();\n        }\n\n        int maxNumber = 0;\n        foreach (int n in distinctNumbers) {\n            if (n > maxNumber) maxNumber = n;\n        }\n\n        BitArray isPrimeSieve = SieveOfEratosthenesBitArray(maxNumber);\n        \n        var primeSet = new HashSet<int>();\n        foreach (int num in distinctNumbers) {\n            if (isPrimeSieve[num]) {\n                primeSet.Add(num);\n            }\n        }\n        return primeSet;\n    }\n\n    /// <summary>\n    /// Generates a list of all prime numbers up to a specified limit using the Sieve of Eratosthenes.\n    /// </summary>\n    /// <param name=\"limit\">The inclusive upper bound for generating primes. Must be non-negative.</param>\n    /// <returns>A list of integers containing all prime numbers from 2 up to the limit.</returns>\n    public static List<int> SievePrimesList(int limit) {\n        if (limit < 2) {\n            return new List<int>();\n        }\n        BitArray isPrimeSieve = SieveOfEratosthenesBitArray(limit);\n        var primes = new List<int>();\n        for (int i = 2; i <= limit; i++) {\n            if (isPrimeSieve[i]) {\n                primes.Add(i);\n            }\n        }\n        return primes;\n    }\n}\n"
    },
    {
      "filename": "InputHandler.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Handles user input for the console application.\n/// Responsible for validating menu selections and managing the application loop flow.\n/// </summary>\npublic static class InputHandler {\n    private const string SolveAllCommand = \"a\";\n    private const string RunTestsCommand = \"t\";\n\n    /// <summary>\n    /// Prompts the user for a menu selection and validates the input.\n    /// Blocks until a valid selection is made.\n    /// </summary>\n    /// <returns>A valid menu selection string (either a command or a problem number).</returns>\n    public static string GetMenuSelection() {\n        string input;\n\n        while (true) {\n            input = Console.ReadLine()?.Trim() ?? string.Empty;\n            Console.WriteLine();\n            if (IsValidSelection(input)) break;\n            Library.FunPrint(\"Invalid input. Please try again.\");\n        }\n\n        return input;\n    }\n\n    /// <summary>\n    /// Checks if the user wants to run the application loop again.\n    /// </summary>\n    /// <returns>True if the user pressed any key other than Space; false if Space was pressed.</returns>\n    public static bool ShouldRunAgain() {\n        Library.FunPrint(\"Press any key to run program again, Space to exit.\");\n        var input = Console.ReadKey(true).Key;\n        return input != ConsoleKey.Spacebar;\n    }\n\n    /// <summary>\n    /// Validates the user's input string against the allowed commands and available problem range.\n    /// </summary>\n    /// <param name=\"input\">The input string to validate.</param>\n    /// <returns>True if the input is a valid command ('a', 't') or a valid problem number; otherwise, false.</returns>\n    private static bool IsValidSelection(string input) {\n        if (string.IsNullOrWhiteSpace(input)) return false;\n        if (int.TryParse(input, out int num))\n            return num > 0 && num <= ProblemFactory.SolvedProblems();\n        return input.Equals(SolveAllCommand, StringComparison.OrdinalIgnoreCase) ||\n               input.Equals(RunTestsCommand, StringComparison.OrdinalIgnoreCase);\n    }\n}\n"
    },
    {
      "filename": "OutputHandler.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "using System.Text;\nusing System.Text.Json;\n\nnamespace Project_Euler;\n\n/// <summary>\n/// Handles the generation of reports for benchmark results.\n/// Outputs data to text log, JSON file, and an interactive HTML report.\n/// </summary>\ninternal static class OutputHandler {\n    /// <summary>\n    /// The filename for the text-based log output.\n    /// </summary>\n    public const string LogFile = \"log.txt\";\n    private const string JsonFile = \"benchmark.json\";\n    private const string HtmlFile = \"benchmark.html\";\n    private const string HtmlTemplate = \"template.html\";\n    private static readonly JsonSerializerOptions JsonOptions = new() { WriteIndented = true };\n\n    /// <summary>\n    /// Generates full benchmark reports (Text, JSON, HTML) based on the provided results.\n    /// </summary>\n    /// <param name=\"results\">A list of <see cref=\"ProblemData\"/> containing results for each problem run.</param>\n    /// <param name=\"testData\">Global benchmark statistics including total time and slowest problem.</param>\n    public static void GenerateFullReport(List<ProblemData> results, BenchmarkData testData) {\n        double sumOfAverageProblemTimes = 0;\n        if (results.Any()) {\n            // Ensure Times list is not empty before calling Average to prevent InvalidOperationException\n            sumOfAverageProblemTimes = results.Sum(r => r.Times.Any() ? r.Times.Average() : 0.0);\n        }\n\n        // Note: testData.TotalTime is the total wall clock time for the benchmark run.\n        // testData.SlowestTime is the average time of the slowest problem (calculated in ProblemSolver).\n\n        WriteBenchmarkReport(results, testData, sumOfAverageProblemTimes);\n        WriteBenchmarkJson(results, testData, sumOfAverageProblemTimes);\n        WriteBenchmarkHtml(results, testData, sumOfAverageProblemTimes);\n    }\n\n    private static void WriteBenchmarkReport(List<ProblemData> results, BenchmarkData testData, double sumOfAverageProblemTimes) {\n        var fileContent = new StringBuilder();\n\n        foreach (var result in results) {\n            fileContent.AppendLine($\"Problem {result.Index:D2}: {result.Result}\");\n            fileContent.AppendLine($\"    Best:   {result.MinTime:F3} ms\");\n            fileContent.AppendLine($\"    Worst:  {result.MaxTime:F3} ms\");\n            fileContent.AppendLine($\"    Avg:    {result.AverageTime:F3} ms\");\n            fileContent.AppendLine();\n        }\n\n        fileContent.AppendLine($\"Total wall-clock benchmark time: {testData.TotalTime:F3} ms\");\n        if (results.Any()) {\n            fileContent.AppendLine($\"Sum of average problem solution times: {sumOfAverageProblemTimes:F3} ms\");\n            fileContent.AppendLine($\"Average problem solution time: {(results.Count > 0 ? sumOfAverageProblemTimes / results.Count : 0):F3} ms\");\n        } else {\n            fileContent.AppendLine($\"Sum of average problem solution times: 0.000 ms\");\n            fileContent.AppendLine($\"Average problem solution time: 0.000 ms\");\n        }\n        fileContent.AppendLine($\"Slowest Problem (by avg time): {testData.SlowestProblem} with {testData.SlowestTime:F3} ms\");\n        File.WriteAllText(LogFile, fileContent.ToString());\n    }\n\n    private static void WriteBenchmarkJson(List<ProblemData> results, BenchmarkData testData, double sumOfAverageProblemTimes) {\n        var summaryJson = new {\n            totalProblems = results.Count,\n            totalWallClockTimeMs = testData.TotalTime, // Renamed for clarity\n            sumOfAverageProblemTimesMs = sumOfAverageProblemTimes, // Added\n            averageProblemSolutionTimeMs = results.Count > 0 ? sumOfAverageProblemTimes / results.Count : 0, // Renamed and logic updated\n            slowestProblem = new {\n                index = testData.SlowestProblem,\n                averageTimeMs = testData.SlowestTime // Renamed for clarity\n            }\n        };\n\n        var problemsJson = results.Select(r => new {\n            index = r.Index,\n            result = r.Result,\n            times = r.Times, // Optionally include all times if needed, or just stats\n            bestTimeMs = r.MinTime,\n            worstTimeMs = r.MaxTime,\n            averageTimeMs = r.AverageTime\n        });\n        \n        var jsonOutput = new {\n            summary = summaryJson,\n            problems = problemsJson\n        };\n\n        string json = JsonSerializer.Serialize(jsonOutput, JsonOptions);\n        File.WriteAllText(JsonFile, json);\n    }\n\n    private static void WriteBenchmarkHtml(List<ProblemData> results, BenchmarkData testData, double sumOfAverageProblemTimes) {\n        var problemsHtml = results.Select(r => new {\n            index = r.Index,\n            result = r.Result,\n            times = r.Times, // Optionally include all times\n            bestTimeMs = r.MinTime,\n            worstTimeMs = r.MaxTime,\n            averageTimeMs = r.AverageTime\n        }).ToList();\n\n        var summaryHtml = new {\n            totalProblems = results.Count,\n            totalWallClockTimeMs = testData.TotalTime, // Renamed\n            sumOfAverageProblemTimesMs = sumOfAverageProblemTimes, // Added\n            averageProblemSolutionTimeMs = results.Count > 0 ? sumOfAverageProblemTimes / results.Count : 0, // Renamed and logic updated\n            slowestProblem = new {\n                index = testData.SlowestProblem,\n                averageTimeMs = testData.SlowestTime // Renamed\n            }\n        };\n\n        string jsonData = JsonSerializer.Serialize(new { summary = summaryHtml, problems = problemsHtml });\n        string htmlTemplate = File.ReadAllText(HtmlTemplate);\n        string finalHtml = htmlTemplate.Replace(\"{{DATA}}\", jsonData);\n\n        File.WriteAllText(HtmlFile, finalHtml);\n    }\n}\n"
    },
    {
      "filename": "SolutionVerifier.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Text.Json;\n\nnamespace Project_Euler;\n\n/// <summary>\n/// Verifies problem solutions against a set of known correct answers.\n/// Supports loading answers from a JSON file and persisting new answers.\n/// </summary>\npublic static class SolutionVerifier\n{\n    private static readonly Dictionary<int, string> KnownAnswers = new();\n    private const string AnswersFile = \"known_answers.json\";\n\n    static SolutionVerifier()\n    {\n        LoadKnownAnswers();\n    }\n\n    /// <summary>\n    /// Loads known answers from the 'known_answers.json' file.\n    /// If the file does not exist or fails to load, falls back to a hardcoded default set.\n    /// </summary>\n    private static void LoadKnownAnswers()\n    {\n        try\n        {\n            if (File.Exists(AnswersFile))\n            {\n                string json = File.ReadAllText(AnswersFile);\n                var answers = JsonSerializer.Deserialize<Dictionary<int, string>>(json);\n                if (answers != null)\n                {\n                    foreach (var kvp in answers)\n                    {\n                        KnownAnswers[kvp.Key] = kvp.Value;\n                    }\n                }\n            }\n            else\n            {\n                // Fallback to hardcoded answers for backward compatibility\n                LoadDefaultAnswers();\n                SaveKnownAnswers(); // Save to file for future use\n            }\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"Warning: Could not load answers from file: {ex.Message}\");\n            LoadDefaultAnswers();\n        }\n    }\n\n    private static void LoadDefaultAnswers()\n    {\n        // Legacy hardcoded answers\n        var defaultAnswers = new Dictionary<int, string>\n        {\n            { 1, \"233168\" },\n            { 2, \"4613732\" },\n            { 3, \"6857\" },\n            { 4, \"906609\" },\n            { 5, \"232792560\" },\n            { 6, \"25164150\" },\n            { 7, \"104743\" },\n            { 8, \"23514624000\" },\n            { 9, \"31875000\" },\n            { 10, \"142913828922\" },\n            { 11, \"70600674\" },\n            { 12, \"76576500\" },\n            { 13, \"5537376230\" },\n            { 14, \"837799\" },\n            { 15, \"137846528820\" },\n            { 16, \"1366\" },\n            { 17, \"21124\" },\n            { 18, \"1074\" },\n            { 19, \"171\" },\n            { 20, \"648\" },\n            { 21, \"31626\" },\n            { 22, \"871198282\" },\n            { 23, \"4179871\" },\n            { 24, \"2783915460\" },\n            { 25, \"4782\" },\n            { 26, \"983\" },\n            { 27, \"-59231\" },\n            { 28, \"669171001\" },\n            { 29, \"9183\" },\n            { 30, \"443839\" },\n            { 31, \"73682\" },\n            { 32, \"45228\" },\n            { 33, \"100\" },\n            { 34, \"40730\" },\n            { 35, \"55\" },\n            { 36, \"872187\" },\n            { 37, \"748317\" },\n            { 38, \"932718654\" },\n            { 39, \"840\" },\n            { 40, \"210\" },\n            { 41, \"7652413\" },\n            { 42, \"162\" },\n            { 43, \"16695334890\" },\n            { 44, \"5482660\" },\n            { 45, \"1533776805\" },\n            { 46, \"5777\" },\n            { 47, \"134043\" },\n            { 48, \"9110846700\" },\n            { 49, \"296962999629\" },\n            { 50, \"997651\" }\n        };\n\n        foreach (var kvp in defaultAnswers)\n        {\n            KnownAnswers[kvp.Key] = kvp.Value;\n        }\n    }\n\n    private static void SaveKnownAnswers()\n    {\n        try\n        {\n            string json = JsonSerializer.Serialize(KnownAnswers, new JsonSerializerOptions { WriteIndented = true });\n            File.WriteAllText(AnswersFile, json);\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"Warning: Could not save answers to file: {ex.Message}\");\n        }\n    }\n\n    /// <summary>\n    /// Verifies the solution for a specific problem ID against the known answer.\n    /// Executes the problem's Solve method and compares the output.\n    /// </summary>\n    /// <param name=\"problemId\">The ID of the problem to verify.</param>\n    /// <returns>True if the solution matches the known answer; false otherwise.</returns>\n    public static bool VerifySolution(int problemId)\n    {\n        if (!KnownAnswers.TryGetValue(problemId, out var expectedAnswer))\n        {\n            Console.WriteLine($\"Warning: No known answer for Problem {problemId}. Cannot verify.\");\n            return false; // Or throw an exception, or return a specific status\n        }\n\n        Problem? problemInstance = null;\n        try\n        {\n            problemInstance = ProblemFactory.CreateProblem(problemId);\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"Error creating instance for Problem {problemId}: {ex.Message}\");\n            return false;\n        }\n\n        if (problemInstance == null)\n        {\n            // This case should ideally be caught by the exception in ProblemFactory or the one above,\n            // but as a fallback:\n            Console.WriteLine($\"Error: Could not create instance for Problem {problemId} (returned null).\");\n            return false;\n        }\n        \n        object? actualResultObject = null;\n        string actualResultString = string.Empty;\n        \n        try\n        {\n            var stopwatch = Stopwatch.StartNew();\n            actualResultObject = problemInstance.Solve();\n            stopwatch.Stop();\n            actualResultString = actualResultObject?.ToString() ?? string.Empty;\n\n            if (actualResultString == expectedAnswer)\n            {\n                Console.WriteLine($\"Problem {problemId}: Correct. (Result: {actualResultString}, Time: {stopwatch.ElapsedMilliseconds} ms)\");\n                return true;\n            }\n            else\n            {\n                Console.WriteLine($\"Problem {problemId}: Incorrect. (Expected: {expectedAnswer}, Actual: {actualResultString}, Time: {stopwatch.ElapsedMilliseconds} ms)\");\n                return false;\n            }\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"Error solving Problem {problemId}: {ex.Message}\");\n            Console.WriteLine($\"Actual result at point of error (if any): '{actualResultString}'\");\n            return false;\n        }\n    }\n\n    /// <summary>\n    /// Iterates through all problems with known answers and verifies their solutions.\n    /// Reports the total number of correct and incorrect solutions.\n    /// </summary>\n    public static void VerifyAllKnownSolutions()\n    {\n        int verifiedCount = 0;\n        int failedCount = 0;\n        var problemIdsToVerify = new List<int>(KnownAnswers.Keys);\n        problemIdsToVerify.Sort(); // Verify in order\n\n        Console.WriteLine($\"Starting verification for {problemIdsToVerify.Count} problems with known answers...\");\n\n        foreach (int problemId in problemIdsToVerify)\n        {\n            if (VerifySolution(problemId))\n            {\n                verifiedCount++;\n            }\n            else\n            {\n                failedCount++;\n            }\n        }\n\n        Console.WriteLine($\"Verification Complete. {verifiedCount} correct, {failedCount} failed (out of {problemIdsToVerify.Count} checked).\");\n    }\n    \n    // Method to add more answers, perhaps from a file or embedded resource later\n    public static void AddKnownAnswer(int problemId, string answer)\n    {\n        KnownAnswers[problemId] = answer;\n    }\n}\n"
    },
    {
      "filename": "BenchmarkRunner.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "using System.Diagnostics;\n\nnamespace Project_Euler;\n\n/// <summary>\n/// Provides advanced benchmarking capabilities with statistical analysis.\n/// Calculates mean, median, standard deviation, and confidence intervals for problem execution times.\n/// </summary>\npublic class BenchmarkRunner\n{\n    private const int WarmupRuns = 10;\n    private const int MinBenchmarkRuns = 30;\n    private const int MaxBenchmarkRuns = 1000;\n    private const double ConfidenceLevel = 0.95; // 95% confidence interval\n\n    /// <summary>\n    /// Represents the results of a benchmark run for a specific problem.\n    /// </summary>\n    public class BenchmarkResult\n    {\n        public int ProblemId { get; set; }\n        public string Result { get; set; } = string.Empty;\n        public double MeanTime { get; set; }\n        public double MedianTime { get; set; }\n        public double StandardDeviation { get; set; }\n        public double MinTime { get; set; }\n        public double MaxTime { get; set; }\n        public int TotalRuns { get; set; }\n        public double ConfidenceInterval { get; set; }\n        public List<double> Times { get; set; } = new();\n    }\n\n    public static BenchmarkResult RunBenchmark(int problemId, Problem problem)\n    {\n        var result = new BenchmarkResult { ProblemId = problemId };\n        \n        // Warm-up phase\n        for (int i = 0; i < WarmupRuns; i++)\n        {\n            problem.Solve();\n        }\n\n        // Benchmark phase with adaptive number of runs\n        var times = new List<double>();\n        var stopwatch = new Stopwatch();\n        \n        // Initial runs to get a baseline\n        for (int i = 0; i < MinBenchmarkRuns; i++)\n        {\n            stopwatch.Restart();\n            var solution = problem.Solve();\n            stopwatch.Stop();\n            \n            if (i == 0)\n            {\n                result.Result = solution?.ToString() ?? string.Empty;\n            }\n            \n            times.Add(stopwatch.Elapsed.TotalMilliseconds);\n        }\n\n        // Calculate initial statistics\n        var stats = CalculateStatistics(times);\n        \n        // Determine if we need more runs for statistical significance\n        int additionalRuns = CalculateRequiredRuns(stats.StandardDeviation, stats.Mean, ConfidenceLevel);\n        additionalRuns = Math.Min(additionalRuns, MaxBenchmarkRuns - MinBenchmarkRuns);\n        \n        // Run additional iterations if needed\n        for (int i = 0; i < additionalRuns; i++)\n        {\n            stopwatch.Restart();\n            problem.Solve();\n            stopwatch.Stop();\n            times.Add(stopwatch.Elapsed.TotalMilliseconds);\n        }\n\n        // Final statistics\n        var finalStats = CalculateStatistics(times);\n        result.MeanTime = finalStats.Mean;\n        result.MedianTime = finalStats.Median;\n        result.StandardDeviation = finalStats.StandardDeviation;\n        result.MinTime = finalStats.Min;\n        result.MaxTime = finalStats.Max;\n        result.TotalRuns = times.Count;\n        result.ConfidenceInterval = CalculateConfidenceInterval(finalStats.StandardDeviation, times.Count, ConfidenceLevel);\n        result.Times = times;\n\n        return result;\n    }\n\n    private static (double Mean, double Median, double StandardDeviation, double Min, double Max) CalculateStatistics(List<double> values)\n    {\n        if (values.Count == 0) return (0, 0, 0, 0, 0);\n\n        var sorted = values.OrderBy(x => x).ToList();\n        var mean = values.Average();\n        var median = sorted[sorted.Count / 2];\n        var min = sorted[0];\n        var max = sorted[sorted.Count - 1];\n        \n        var variance = values.Sum(x => Math.Pow(x - mean, 2)) / values.Count;\n        var standardDeviation = Math.Sqrt(variance);\n\n        return (mean, median, standardDeviation, min, max);\n    }\n\n    private static int CalculateRequiredRuns(double standardDeviation, double mean, double confidenceLevel)\n    {\n        if (mean == 0) return 0;\n        \n        // Using t-distribution approximation for sample size calculation\n        // For 95% confidence level, t \u2248 1.96\n        var tValue = 1.96;\n        var coefficientOfVariation = standardDeviation / mean;\n        var marginOfError = 0.05; // 5% margin of error\n        \n        var requiredRuns = (int)Math.Ceiling(Math.Pow(tValue * coefficientOfVariation / marginOfError, 2));\n        return Math.Max(0, requiredRuns - MinBenchmarkRuns);\n    }\n\n    private static double CalculateConfidenceInterval(double standardDeviation, int sampleSize, double confidenceLevel)\n    {\n        if (sampleSize <= 1) return 0;\n        \n        // Using t-distribution for small samples\n        var tValue = 1.96; // Approximation for large samples\n        return tValue * standardDeviation / Math.Sqrt(sampleSize);\n    }\n\n    public static List<BenchmarkResult> RunAllBenchmarks()\n    {\n        var results = new List<BenchmarkResult>();\n        var problemCount = ProblemFactory.SolvedProblems();\n        \n        Logger.Info($\"Starting benchmark of {problemCount} problems\");\n        \n        for (int i = 1; i <= problemCount; i++)\n        {\n            try\n            {\n                using (Logger.CreateScope($\"Problem {i}\"))\n                {\n                    var problem = ProblemFactory.CreateProblem(i);\n                    var result = RunBenchmark(i, problem);\n                    results.Add(result);\n                    \n                    Logger.Info($\"Problem {i}: {result.MeanTime:F3}ms \u00b1 {result.ConfidenceInterval:F3}ms ({result.TotalRuns} runs)\");\n                }\n            }\n            catch (Exception ex)\n            {\n                Logger.Error($\"Failed to benchmark problem {i}\", ex);\n            }\n        }\n        \n        Logger.Info($\"Completed benchmark of {results.Count} problems\");\n        return results;\n    }\n}\n"
    },
    {
      "filename": "Logger.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "using System.Diagnostics;\n\nnamespace Project_Euler;\n\n/// <summary>\n/// Defines the severity levels for log messages.\n/// </summary>\npublic enum LogLevel\n{\n    Debug,\n    Info,\n    Warning,\n    Error\n}\n\n/// <summary>\n/// A thread-safe static logger class for logging messages to the console and a file.\n/// Supports different log levels and scoped logging blocks.\n/// </summary>\npublic static class Logger\n{\n    private static readonly object _lock = new object();\n    private static readonly string LogFile = \"euler_solver.log\";\n    private static LogLevel _minLevel = LogLevel.Info;\n\n    /// <summary>\n    /// Sets the minimum log level. Messages below this level will be ignored.\n    /// </summary>\n    /// <param name=\"level\">The minimum log level to capture.</param>\n    public static void SetLogLevel(LogLevel level)\n    {\n        _minLevel = level;\n    }\n\n    /// <summary>\n    /// Logs a message at the Debug level.\n    /// </summary>\n    /// <param name=\"message\">The message to log.</param>\n    public static void Debug(string message)\n    {\n        Log(LogLevel.Debug, message);\n    }\n\n    /// <summary>\n    /// Logs a message at the Info level.\n    /// </summary>\n    /// <param name=\"message\">The message to log.</param>\n    public static void Info(string message)\n    {\n        Log(LogLevel.Info, message);\n    }\n\n    /// <summary>\n    /// Logs a message at the Warning level.\n    /// </summary>\n    /// <param name=\"message\">The message to log.</param>\n    public static void Warning(string message)\n    {\n        Log(LogLevel.Warning, message);\n    }\n\n    /// <summary>\n    /// Logs a message at the Error level, optionally including an exception.\n    /// </summary>\n    /// <param name=\"message\">The error message.</param>\n    /// <param name=\"exception\">The exception associated with the error (optional).</param>\n    public static void Error(string message, Exception? exception = null)\n    {\n        var fullMessage = exception != null \n            ? $\"{message} Exception: {exception.Message}\" \n            : message;\n        Log(LogLevel.Error, fullMessage);\n    }\n\n    private static void Log(LogLevel level, string message)\n    {\n        if (level < _minLevel) return;\n\n        var timestamp = DateTime.Now.ToString(\"yyyy-MM-dd HH:mm:ss.fff\");\n        var logEntry = $\"[{timestamp}] [{level}] {message}\";\n\n        lock (_lock)\n        {\n            Console.WriteLine(logEntry);\n            \n            try\n            {\n                File.AppendAllText(LogFile, logEntry + Environment.NewLine);\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"[{timestamp}] [ERROR] Failed to write to log file: {ex.Message}\");\n            }\n        }\n    }\n\n    /// <summary>\n    /// Creates a disposable scope for logging.\n    /// Logs a start message on creation and a completion message with elapsed time on disposal.\n    /// Useful for tracing the execution time of blocks of code.\n    /// </summary>\n    /// <param name=\"scopeName\">The name of the scope to log.</param>\n    /// <returns>An IDisposable object that ends the scope when disposed.</returns>\n    public static IDisposable CreateScope(string scopeName)\n    {\n        return new LogScope(scopeName);\n    }\n\n    private class LogScope : IDisposable\n    {\n        private readonly string _scopeName;\n        private readonly Stopwatch _stopwatch;\n\n        public LogScope(string scopeName)\n        {\n            _scopeName = scopeName;\n            _stopwatch = Stopwatch.StartNew();\n            Logger.Info($\"Starting: {_scopeName}\");\n        }\n\n        public void Dispose()\n        {\n            _stopwatch.Stop();\n            Logger.Info($\"Completed: {_scopeName} (took {_stopwatch.ElapsedMilliseconds}ms)\");\n        }\n    }\n}\n"
    },
    {
      "filename": "Configuration.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "using System.Text.Json;\n\nnamespace Project_Euler;\n\n/// <summary>\n/// Singleton configuration manager for the Project Euler application.\n/// Handles loading and saving settings for benchmarking, logging, and problem execution.\n/// </summary>\npublic class Configuration\n{\n    private static Configuration? _instance;\n    private static readonly object _lock = new object();\n    private const string ConfigFile = \"euler_config.json\";\n\n    public BenchmarkSettings Benchmark { get; set; } = new();\n    public LoggingSettings Logging { get; set; } = new();\n    public ProblemSettings Problems { get; set; } = new();\n\n    public static Configuration Instance\n    {\n        get\n        {\n            if (_instance == null)\n            {\n                lock (_lock)\n                {\n                    _instance ??= LoadConfiguration();\n                }\n            }\n            return _instance;\n        }\n    }\n\n    private static Configuration LoadConfiguration()\n    {\n        try\n        {\n            if (File.Exists(ConfigFile))\n            {\n                var json = File.ReadAllText(ConfigFile);\n                var config = JsonSerializer.Deserialize<Configuration>(json);\n                if (config != null)\n                {\n                    Logger.Info(\"Configuration loaded from file\");\n                    return config;\n                }\n            }\n        }\n        catch (Exception ex)\n        {\n            Logger.Warning($\"Failed to load configuration: {ex.Message}\");\n        }\n\n        // Return default configuration\n        var defaultConfig = new Configuration();\n        defaultConfig.SaveConfiguration();\n        Logger.Info(\"Using default configuration\");\n        return defaultConfig;\n    }\n\n    public void SaveConfiguration()\n    {\n        try\n        {\n            var options = new JsonSerializerOptions { WriteIndented = true };\n            var json = JsonSerializer.Serialize(this, options);\n            File.WriteAllText(ConfigFile, json);\n            Logger.Info(\"Configuration saved to file\");\n        }\n        catch (Exception ex)\n        {\n            Logger.Error(\"Failed to save configuration\", ex);\n        }\n    }\n}\n\npublic class BenchmarkSettings\n{\n    public int WarmupRuns { get; set; } = 10;\n    public int MinBenchmarkRuns { get; set; } = 30;\n    public int MaxBenchmarkRuns { get; set; } = 1000;\n    public double ConfidenceLevel { get; set; } = 0.95;\n    public double MarginOfError { get; set; } = 0.05;\n    public bool EnableParallelExecution { get; set; } = true;\n    public int MaxParallelThreads { get; set; } = Environment.ProcessorCount;\n}\n\npublic class LoggingSettings\n{\n    public LogLevel MinimumLevel { get; set; } = LogLevel.Info;\n    public bool EnableFileLogging { get; set; } = true;\n    public bool EnableConsoleLogging { get; set; } = true;\n    public string LogFilePath { get; set; } = \"euler_solver.log\";\n    public int MaxLogFileSizeMB { get; set; } = 10;\n    public int MaxLogFiles { get; set; } = 5;\n}\n\npublic class ProblemSettings\n{\n    public int MaxProblemId { get; set; } = 900;\n    public bool EnableCaching { get; set; } = true;\n    public int CacheSizeMB { get; set; } = 100;\n    public bool EnableProgressReporting { get; set; } = true;\n    public int ProgressUpdateIntervalMs { get; set; } = 100;\n}\n"
    },
    {
      "filename": "MemoryEfficientCache.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "using System.Collections;\n\nnamespace Project_Euler;\n\n/// <summary>\n/// Provides memory-efficient caching strategies for Project Euler problems.\n/// </summary>\npublic static class MemoryEfficientCache\n{\n    /// <summary>\n    /// Creates a memory-efficient cache for Collatz sequence lengths.\n    /// Uses a sparse array approach to save memory for large ranges.\n    /// </summary>\n    /// <param name=\"maxValue\">Maximum value to cache</param>\n    /// <param name=\"sparsityFactor\">How sparse the cache should be (higher = less memory)</param>\n    /// <returns>A cache that can store Collatz sequence lengths</returns>\n    public static ICollatzCache CreateCollatzCache(uint maxValue, int sparsityFactor = 1)\n    {\n        if (sparsityFactor <= 0) sparsityFactor = 1;\n        \n        // For small ranges, use dense array\n        if (maxValue <= 1000000)\n        {\n            return new DenseCollatzCache(maxValue);\n        }\n        \n        // For large ranges, use sparse array\n        return new SparseCollatzCache(maxValue, sparsityFactor);\n    }\n\n    /// <summary>\n    /// Creates a memory-efficient prime sieve using BitArray.\n    /// </summary>\n    /// <param name=\"maxValue\">Maximum value to sieve</param>\n    /// <returns>A BitArray where true indicates prime numbers</returns>\n    public static BitArray CreatePrimeSieve(int maxValue)\n    {\n        return Library.SieveOfEratosthenesBitArray(maxValue);\n    }\n\n    /// <summary>\n    /// Creates a memory-efficient divisor sum cache.\n    /// </summary>\n    /// <param name=\"maxValue\">Maximum value to cache</param>\n    /// <returns>A cache for divisor sums</returns>\n    public static IDivisorSumCache CreateDivisorSumCache(int maxValue)\n    {\n        return new DivisorSumCache(maxValue);\n    }\n}\n\npublic interface ICollatzCache\n{\n    ushort GetSequenceLength(ulong number);\n    void SetSequenceLength(ulong number, ushort length);\n    bool Contains(ulong number);\n}\n\npublic interface IDivisorSumCache\n{\n    int GetDivisorSum(int number);\n    void SetDivisorSum(int number, int sum);\n    bool Contains(int number);\n}\n\n/// <summary>\n/// Dense cache for small ranges - uses full array.\n/// </summary>\npublic class DenseCollatzCache : ICollatzCache\n{\n    private readonly ushort[] _cache;\n    private readonly uint _maxValue;\n\n    public DenseCollatzCache(uint maxValue)\n    {\n        _maxValue = maxValue;\n        _cache = new ushort[maxValue + 1];\n    }\n\n    public ushort GetSequenceLength(ulong number)\n    {\n        return number <= _maxValue ? _cache[number] : (ushort)0;\n    }\n\n    public void SetSequenceLength(ulong number, ushort length)\n    {\n        if (number <= _maxValue)\n        {\n            _cache[number] = length;\n        }\n    }\n\n    public bool Contains(ulong number)\n    {\n        return number <= _maxValue && _cache[number] != 0;\n    }\n}\n\n/// <summary>\n/// Sparse cache for large ranges - uses dictionary for memory efficiency.\n/// </summary>\npublic class SparseCollatzCache : ICollatzCache\n{\n    private readonly Dictionary<ulong, ushort> _cache;\n    private readonly uint _maxValue;\n    private readonly int _sparsityFactor;\n\n    public SparseCollatzCache(uint maxValue, int sparsityFactor)\n    {\n        _maxValue = maxValue;\n        _sparsityFactor = sparsityFactor;\n        _cache = new Dictionary<ulong, ushort>();\n    }\n\n    public ushort GetSequenceLength(ulong number)\n    {\n        return _cache.TryGetValue(number, out var length) ? length : (ushort)0;\n    }\n\n    public void SetSequenceLength(ulong number, ushort length)\n    {\n        if (number <= _maxValue && number % (ulong)_sparsityFactor == 0)\n        {\n            _cache[number] = length;\n        }\n    }\n\n    public bool Contains(ulong number)\n    {\n        return _cache.ContainsKey(number);\n    }\n}\n\n/// <summary>\n/// Memory-efficient cache for divisor sums.\n/// </summary>\npublic class DivisorSumCache : IDivisorSumCache\n{\n    private readonly int[] _cache;\n    private readonly int _maxValue;\n\n    public DivisorSumCache(int maxValue)\n    {\n        _maxValue = maxValue;\n        _cache = new int[maxValue + 1];\n        InitializeCache();\n    }\n\n    private void InitializeCache()\n    {\n        // Initialize with 1 (every number is divisible by 1)\n        for (int i = 1; i <= _maxValue; i++)\n        {\n            _cache[i] = 1;\n        }\n\n        // Add other divisors\n        for (int i = 2; i <= _maxValue; i++)\n        {\n            for (int j = 2 * i; j <= _maxValue; j += i)\n            {\n                _cache[j] += i;\n            }\n        }\n    }\n\n    public int GetDivisorSum(int number)\n    {\n        return number <= _maxValue ? _cache[number] : 0;\n    }\n\n    public void SetDivisorSum(int number, int sum)\n    {\n        if (number <= _maxValue)\n        {\n            _cache[number] = sum;\n        }\n    }\n\n    public bool Contains(int number)\n    {\n        return number <= _maxValue;\n    }\n}\n"
    },
    {
      "filename": "Problem.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Base class for all Project Euler problem solutions.\n/// </summary>\npublic abstract class Problem<T> where T : struct\n{\n    /// <summary>\n    /// Solves the problem and returns the result.\n    /// </summary>\n    /// <returns>The solution to the problem.</returns>\n    public abstract T Solve();\n\n    /// <summary>\n    /// Gets the problem number from the class name.\n    /// </summary>\n    /// <returns>The problem number.</returns>\n    public int GetProblemNumber()\n    {\n        string className = GetType().Name;\n        if (className.StartsWith(\"Problem\") && int.TryParse(className.AsSpan(7), out int id))\n            return id;\n        throw new InvalidOperationException($\"Cannot extract problem number from class name: {className}\");\n    }\n}\n\n/// <summary>\n/// Legacy base class for backward compatibility.\n/// </summary>\npublic abstract class Problem\n{\n    /// <summary>\n    /// Solves the problem and returns the result as an object.\n    /// </summary>\n    /// <returns>The solution.</returns>\n    public abstract object Solve();\n}\n"
    },
    {
      "filename": "Problem001.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 1: Multiples of 3 or 5.\n/// Finds the sum of all the multiples of 3 or 5 below 1000.\n/// </summary>\npublic class Problem001 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 1: Multiples of 3 or 5.\n    /// Finds the sum of all the multiples of 3 or 5 below 1000.\n    /// </summary>\n    /// <returns>The sum of all multiples of 3 or 5 below 1000.</returns>\n    public override object Solve() {\n        return SumMultiples(3, 5, 1000);\n    }\n\n    /// <summary>\n    /// Calculates the sum of all multiples of m1 or m2 that are less than n.\n    /// This method uses the principle of inclusion-exclusion to avoid double-counting multiples of both m1 and m2.\n    /// </summary>\n    /// <param name=\"m1\">The first multiple.</param>\n    /// <param name=\"m2\">The second multiple.</param>\n    /// <param name=\"n\">The upper limit (exclusive).</param>\n    /// <returns>The sum of multiples of m1 or m2 below n.</returns>\n    private int SumMultiples(int m1, int m2, int n) {\n        return SumDivisibleBy(m1, n - 1) +\n               SumDivisibleBy(m2, n - 1) -\n               SumDivisibleBy(Lcm(m1, m2), n - 1);\n    }\n\n    /// <summary>\n    /// Calculates the sum of all numbers divisible by m up to a given limit.\n    /// It uses the formula for the sum of an arithmetic series.\n    /// </summary>\n    /// <param name=\"m\">The divisor.</param>\n    /// <param name=\"limit\">The upper limit (inclusive).</param>\n    /// <returns>The sum of all numbers divisible by m up to the limit.</returns>\n    private int SumDivisibleBy(int m, int limit) {\n        int p = limit / m;\n        return m * p * (p + 1) / 2;\n    }\n\n    /// <summary>\n    /// Calculates the Least Common Multiple (LCM) of two integers a and b.\n    /// Uses the formula LCM(a,b) = |a*b| / GCD(a,b).\n    /// </summary>\n    /// <param name=\"a\">The first integer.</param>\n    /// <param name=\"b\">The second integer.</param>\n    /// <returns>The LCM of a and b.</returns>\n    private int Lcm(int a, int b) {\n        return a / Library.Gcd(a, b) * b;\n    }\n}\n"
    },
    {
      "filename": "Problem002.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 2: Even Fibonacci Numbers.\n/// Finds the sum of the even-valued terms in the Fibonacci sequence\n/// whose values do not exceed four million.\n/// </summary>\npublic class Problem002 : Problem {\n    /// <summary>\n    /// The limit for the Fibonacci sequence values.\n    /// </summary>\n    private const int Limit = 4000000;\n\n    /// <summary>\n    /// Solves Project Euler Problem 2: Even Fibonacci Numbers.\n    /// Finds the sum of the even-valued terms in the Fibonacci sequence \n    /// whose values do not exceed four million.\n    /// </summary>\n    /// <returns>The sum of even-valued Fibonacci terms below four million.</returns>\n    public override object Solve() {\n        return EvenFibSum();\n    }\n\n    /// <summary>\n    /// Calculates the sum of even-valued Fibonacci numbers that do not exceed the defined Limit.\n    /// It uses the recurrence relation E_n = 4 * E_{n-1} + E_{n-2} for even Fibonacci numbers,\n    /// starting with E_1 = 2 and E_2 = 8.\n    /// </summary>\n    /// <returns>The sum of even Fibonacci numbers up to the Limit.</returns>\n    private int EvenFibSum() {\n        // Even Fibonacci numbers follow the recurrence: E_n = 4 * E_{n-1} + E_{n-2}\n        // Starting with E_1 = 2, E_2 = 8.\n        int fib1 = 2;\n        int fib2 = 8;\n        int sum = fib1; // Start sum with the first even term if it's below limit\n\n        if (fib1 >= Limit) return 0; // No terms if the first is already too large\n        if (fib2 < Limit) sum += fib2; else return sum; // Add second term if within limit\n\n        while (true) {\n            int nextFib = 4 * fib2 + fib1;\n            if (nextFib >= Limit) break;\n            sum += nextFib;\n            (fib1, fib2) = (fib2, nextFib);\n        }\n\n        return sum;\n    }\n}\n"
    },
    {
      "filename": "Problem003.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 3: Largest prime factor.\n/// Finds the largest prime factor of the number 600851475143.\n/// </summary>\npublic class Problem003 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 3: Largest prime factor.\n    /// Finds the largest prime factor of the number 600851475143.\n    /// </summary>\n    /// <returns>The largest prime factor of 600851475143.</returns>\n    public override object Solve() {\n        return LargestPrimeFactor(600851475143);\n    }\n\n    /// <summary>\n    /// Calculates the largest prime factor of a given number n.\n    /// It repeatedly divides n by its smallest prime factor until n becomes 1.\n    /// The last factor used in the division is the largest prime factor.\n    /// </summary>\n    /// <param name=\"n\">The number to factorize.</param>\n    /// <returns>The largest prime factor of n.</returns>\n    private long LargestPrimeFactor(long n) {\n        long largestFactor = -1;\n\n        // Check for factor 2\n        while (n % 2 == 0) {\n            largestFactor = 2;\n            n /= 2;\n        }\n\n        // Check for odd factors starting from 3\n        for (long i = 3; i * i <= n; i += 2) {\n            while (n % i == 0) {\n                largestFactor = i;\n                n /= i;\n            }\n        }\n\n        // If n is still greater than 2, then n itself is a prime factor\n        if (n > 2) {\n            largestFactor = n;\n        }\n\n        return largestFactor;\n    }\n}\n"
    },
    {
      "filename": "Problem004.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 4: Largest palindrome product.\n/// Finds the largest palindrome made from the product of two 3-digit numbers.\n/// </summary>\npublic class Problem004 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 4: Largest palindrome product.\n    /// Finds the largest palindrome made from the product of two 3-digit numbers.\n    /// </summary>\n    /// <returns>The largest palindrome product of two 3-digit numbers.</returns>\n    public override object Solve() {\n        return LargestPalindromeProduct(3);\n    }\n\n    /// <summary>\n    /// Finds the largest palindrome made from the product of two numbers with the specified number of digits.\n    /// Iterates downwards from the largest possible n-digit numbers to find the maximum palindrome product.\n    /// </summary>\n    /// <param name=\"digits\">The number of digits for the factors (e.g., 3 for 3-digit numbers).</param>\n    /// <returns>The largest palindrome product.</returns>\n    private int LargestPalindromeProduct(int digits) {\n        int max = Library.Pow10(digits) - 1;\n        int min = Library.Pow10(digits - 1);\n        int largestPalindrome = 0;\n\n        for (int i = max; i >= min; i--) {\n            // Optimization: If i * max is less than the current largest palindrome, we can stop the inner loop/search.\n            // But strict optimization isn't critical for 3 digits.\n            if (i * max <= largestPalindrome) break; \n            \n            for (int j = i; j >= min; j--) {\n                int product = i * j;\n                if (product <= largestPalindrome) break; // Since j is decreasing, subsequent products will be smaller.\n\n                if (Library.IsPalindrome(product)) {\n                    largestPalindrome = product;\n                }\n            }\n        }\n        return largestPalindrome;\n    }\n}\n"
    },
    {
      "filename": "Problem005.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 5: Smallest multiple.\n/// Finds the smallest positive number that is evenly divisible by all of the numbers from 1 to 20.\n/// </summary>\npublic class Problem005 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 5: Smallest multiple.\n    /// Finds the smallest positive number that is evenly divisible by all of the numbers from 1 to 20.\n    /// </summary>\n    /// <returns>The smallest multiple of numbers from 1 to 20.</returns>\n    public override object Solve() {\n        return SmallestMultiple(20);\n    }\n\n    /// <summary>\n    /// Calculates the smallest number divisible by all numbers from 1 to k.\n    /// This is equivalent to finding the Least Common Multiple (LCM) of the numbers 1, 2, ..., k.\n    /// LCM(1, ..., k) = LCM(LCM(1, ..., k-1), k).\n    /// </summary>\n    /// <param name=\"k\">The upper limit of the range [1, k].</param>\n    /// <returns>The smallest multiple of 1 through k.</returns>\n    private long SmallestMultiple(int k) {\n        long lcm = 1;\n        for (int i = 2; i <= k; i++) {\n            lcm = Lcm(lcm, i);\n        }\n        return lcm;\n    }\n\n    /// <summary>\n    /// Calculates the Least Common Multiple (LCM) of two numbers a and b.\n    /// LCM(a, b) = |a * b| / GCD(a, b).\n    /// </summary>\n    /// <param name=\"a\">The first number.</param>\n    /// <param name=\"b\">The second number.</param>\n    /// <returns>The LCM of a and b.</returns>\n    private long Lcm(long a, long b) {\n        // Use Library.Gcd but handle long types\n        // GCD(a, b) fits in int if inputs were int, but here inputs are long.\n        // We can implement a local LongGcd or cast if we are sure of range.\n        // For Problem 5, result fits in long, inputs are small.\n        // Let's implement LongGcd locally to be safe.\n        return (a * b) / Gcd(a, b);\n    }\n\n    /// <summary>\n    /// Calculates GCD of two long integers.\n    /// </summary>\n    private long Gcd(long a, long b) {\n        while (b != 0) {\n            long temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return Math.Abs(a);\n    }\n}\n"
    },
    {
      "filename": "Problem006.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 6: Sum square difference.\n/// Finds the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.\n/// </summary>\npublic class Problem006 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 6: Sum square difference.\n    /// Finds the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.\n    /// </summary>\n    /// <returns>The difference between the square of the sum and the sum of the squares for the first 100 natural numbers.</returns>\n    public override object Solve() {\n        return SumSquareDifference(100);\n    }\n\n    /// <summary>\n    /// Calculates the difference between the square of the sum and the sum of the squares for numbers from 1 to n.\n    /// Uses closed-form formulas:\n    /// Sum(1..n) = n(n+1)/2\n    /// Sum(i^2 for i=1..n) = n(n+1)(2n+1)/6\n    /// </summary>\n    /// <param name=\"n\">The upper limit of the natural numbers.</param>\n    /// <returns>The difference (Square of Sum - Sum of Squares).</returns>\n    private long SumSquareDifference(int n) {\n        long sum = n * (n + 1) / 2;\n        long squareOfSum = sum * sum;\n\n        long sumOfSquares = n * (n + 1) * (2 * n + 1) / 6;\n\n        return squareOfSum - sumOfSquares;\n    }\n}\n"
    },
    {
      "filename": "Problem007.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 7: 10001st prime.\n/// Finds the 10 001st prime number.\n/// </summary>\npublic class Problem007 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 7: 10001st prime.\n    /// Finds the 10 001st prime number.\n    /// </summary>\n    /// <returns>The 10 001st prime number.</returns>\n    public override object Solve() {\n        return NthPrime(10001);\n    }\n\n    /// <summary>\n    /// Finds the nth prime number.\n    /// Uses the trial division method (via Library.IsPrime) to find primes sequentially.\n    /// </summary>\n    /// <param name=\"n\">The rank of the prime to find (e.g., 1 for 2, 2 for 3).</param>\n    /// <returns>The nth prime number.</returns>\n    private int NthPrime(int n) {\n        if (n == 1) return 2;\n        int count = 1; // We have found '2'\n        int candidate = 1;\n\n        while (count < n) {\n            candidate += 2; // Check only odd numbers\n            if (Library.IsPrime(candidate)) {\n                count++;\n            }\n        }\n        return candidate;\n    }\n}\n"
    },
    {
      "filename": "Problem008.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 8: Largest product in a series.\n/// Finds the thirteen adjacent digits in the 1000-digit number that have the greatest product.\n/// </summary>\npublic class Problem008 : Problem {\n    /// <summary>\n    /// The 1000-digit number as a string constant.\n    /// </summary>\n    private const string BigString =\n        \"7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843\" +\n        \"8586156078911294949545950173795833195285320880551112540698747158523863050715693290963295227443043557\" +\n        \"6689664895044524452316173185640309871112172238311362229893423380308135336276614282806444486645238749\" +\n        \"3035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776\" +\n        \"6572733300105336788122023542180975125454059475224352584907711670556013604839586446706324415722155397\" +\n        \"5369781797784617406495514929086256932197846862248283972241375657056057490261407972968652414535100474\" +\n        \"8216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586\" +\n        \"1786645835912456652947654568284891288314260769004224219022671055626321111109370544217506941658960408\" +\n        \"0719840385096245544436298123098787992724428490918884580156166097919133875499200524063689912560717606\" +\n        \"0588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450\";\n\n    /// <summary>\n    /// Solves Project Euler Problem 8: Largest product in a series.\n    /// Finds the thirteen adjacent digits in the 1000-digit number that have the greatest product.\n    /// </summary>\n    /// <returns>The value of this product.</returns>\n    public override object Solve() {\n        return LargestProductString(13, BigString);\n    }\n\n    /// <summary>\n    /// Finds the largest product of 'len' adjacent digits in the given 'digitString'.\n    /// </summary>\n    /// <param name=\"len\">The number of adjacent digits to consider for the product.</param>\n    /// <param name=\"digitString\">The string of digits to search within.</param>\n    /// <returns>The largest product found.</returns>\n    private long LargestProductString(int len, string digitString) {\n        if (digitString == null) throw new ArgumentNullException(nameof(digitString));\n        if (len <= 0 || len > digitString.Length) throw new ArgumentOutOfRangeException(nameof(len));\n\n        long highestProduct = 0;\n        for (int i = 0; i <= digitString.Length - len; i++) {\n            long currentProduct = 1;\n            bool containsZero = false;\n            for (int k = 0; k < len; k++) {\n                char c = digitString[i + k];\n                if (c == '0') {\n                    containsZero = true;\n                    break;\n                }\n                currentProduct *= (c & 15);\n            }\n\n            if (!containsZero && currentProduct > highestProduct) {\n                highestProduct = currentProduct;\n            }\n        }\n\n        return highestProduct;\n    }\n}\n"
    },
    {
      "filename": "Problem009.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 9: Special Pythagorean triplet.\n/// Finds the Pythagorean triplet for which a + b + c = 1000.\n/// </summary>\npublic class Problem009 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 9: Special Pythagorean triplet.\n    /// </summary>\n    /// <returns>The product abc of the Pythagorean triplet for which a + b + c = 1000.</returns>\n    public override object Solve() {\n        return PythagoreanTripletProduct(1000);\n    }\n\n    /// <summary>\n    /// Finds the product abc of a Pythagorean triplet (a, b, c) where a + b + c = n.\n    /// </summary>\n    /// <param name=\"n\">The target sum.</param>\n    /// <returns>The product a*b*c.</returns>\n    private int PythagoreanTripletProduct(int n) {\n        // a < b < c\n        // a < n/3\n        for (int a = 1; a < n / 3; a++) {\n            for (int b = a + 1; b < (n - a) / 2; b++) {\n                int c = n - a - b;\n                if (c > b && IsTriplet(a, b, c)) {\n                    return a * b * c;\n                }\n            }\n        }\n        return 0;\n    }\n\n    /// <summary>\n    /// Checks if (a, b, c) is a Pythagorean triplet.\n    /// </summary>\n    private bool IsTriplet(int a, int b, int c) {\n        return (long)a * a + (long)b * b == (long)c * c;\n    }\n}\n"
    },
    {
      "filename": "Problem010.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "using System.Collections;\n\nnamespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 10: Summation of primes.\n/// Finds the sum of all the primes below two million.\n/// </summary>\npublic class Problem010 : Problem {\n    /// <summary>\n    /// The limit for the sum of primes.\n    /// </summary>\n    private const int Limit = 2000000;\n\n    /// <summary>\n    /// Pre-computed sieve of primes.\n    /// </summary>\n    private readonly BitArray _isPrime;\n\n    /// <summary>\n    /// Initializes a new instance of the <see cref=\"Problem010\"/> class.\n    /// Pre-computes primes using a sieve.\n    /// </summary>\n    public Problem010() {\n        _isPrime = Library.SieveOfEratosthenesBitArray(Limit);\n    }\n\n    /// <summary>\n    /// Solves Project Euler Problem 10: Summation of primes.\n    /// </summary>\n    /// <returns>The sum of all primes below two million.</returns>\n    public override object Solve() {\n        return SumPrimesBelow();\n    }\n\n    /// <summary>\n    /// Calculates the sum of primes up to Limit.\n    /// </summary>\n    /// <returns>The sum of primes.</returns>\n    private long SumPrimesBelow() {\n        long sum = 0;\n        for (int i = 2; i <= Limit; i++) {\n            if (_isPrime[i]) {\n                sum += i;\n            }\n        }\n        return sum;\n    }\n}\n"
    },
    {
      "filename": "Problem011.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "using System.Numerics;\n\nnamespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 11: Largest product in a grid.\n/// Finds the greatest product of four adjacent numbers in the same direction (up, down, left, right, or diagonally) in a 20x20 grid.\n/// </summary>\npublic class Problem011 : Problem {\n    /// <summary>\n    /// The 20x20 grid of numbers represented as a 2D integer array.\n    /// </summary>\n    private readonly int[,] _grid = {\n        {08, 02, 22, 97, 38, 15, 00, 40, 00, 75, 04, 05, 07, 78, 52, 12, 50, 77, 91, 08},\n        {49, 49, 99, 40, 17, 81, 18, 57, 60, 87, 17, 40, 98, 43, 69, 48, 04, 56, 62, 00},\n        {81, 49, 31, 73, 55, 79, 14, 29, 93, 71, 40, 67, 53, 88, 30, 03, 49, 13, 36, 65},\n        {52, 70, 95, 23, 04, 60, 11, 42, 69, 24, 68, 56, 01, 32, 56, 71, 37, 02, 36, 91},\n        {22, 31, 16, 71, 51, 67, 63, 89, 41, 92, 36, 54, 22, 40, 40, 28, 66, 33, 13, 80},\n        {24, 47, 32, 60, 99, 03, 45, 02, 44, 75, 33, 53, 78, 36, 84, 20, 35, 17, 12, 50},\n        {32, 98, 81, 28, 64, 23, 67, 10, 26, 38, 40, 67, 59, 54, 70, 66, 18, 38, 64, 70},\n        {67, 26, 20, 68, 02, 62, 12, 20, 95, 63, 94, 39, 63, 08, 40, 91, 66, 49, 94, 21},\n        {24, 55, 58, 05, 66, 73, 99, 26, 97, 17, 78, 78, 96, 83, 14, 88, 34, 89, 63, 72},\n        {21, 36, 23, 09, 75, 00, 76, 44, 20, 45, 35, 14, 00, 61, 33, 97, 34, 31, 33, 95},\n        {78, 17, 53, 28, 22, 75, 31, 67, 15, 94, 03, 80, 04, 62, 16, 14, 09, 53, 56, 92},\n        {16, 39, 05, 42, 96, 35, 31, 47, 55, 58, 88, 24, 00, 17, 54, 24, 36, 29, 85, 57},\n        {86, 56, 00, 48, 35, 71, 89, 07, 05, 44, 44, 37, 44, 60, 21, 58, 51, 54, 17, 58},\n        {19, 80, 81, 68, 05, 94, 47, 69, 28, 73, 92, 13, 86, 52, 17, 77, 04, 89, 55, 40},\n        {04, 52, 08, 83, 97, 35, 99, 16, 07, 97, 57, 32, 16, 26, 26, 79, 33, 27, 98, 66},\n        {88, 36, 68, 87, 57, 62, 20, 72, 03, 46, 33, 67, 46, 55, 12, 32, 63, 93, 53, 69},\n        {04, 42, 16, 73, 38, 25, 39, 11, 24, 94, 72, 18, 08, 46, 29, 32, 40, 62, 76, 36},\n        {20, 69, 36, 41, 72, 30, 23, 88, 34, 62, 99, 69, 82, 67, 59, 85, 74, 04, 36, 16},\n        {20, 73, 35, 29, 78, 31, 90, 01, 74, 31, 49, 71, 48, 86, 81, 16, 23, 57, 05, 54},\n        {01, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33, 48, 61, 43, 52, 01, 89, 19, 67, 48}\n    };\n\n    /// <summary>\n    /// Solves Project Euler Problem 11: Largest product in a grid.\n    /// Finds the greatest product of four adjacent numbers in the same direction (up, down, left, right, or diagonally) in the 20x20 grid.\n    /// </summary>\n    /// <returns>The greatest product of four adjacent numbers in the grid.</returns>\n    public override object Solve() {\n        return LargestGridProduct();\n    }\n\n    /// <summary>\n    /// Iterates through the grid to find the largest product of 4 consecutive numbers\n    /// in horizontal, vertical, and diagonal directions.\n    /// </summary>\n    /// <returns>The maximum product found.</returns>\n    private int LargestGridProduct() {\n        int maxProduct = 0;\n        int size = 20;\n\n        for (int y = 0; y < size; y++) {\n            for (int x = 0; x < size; x++) {\n                // Horizontal (Right)\n                if (x + 3 < size) {\n                    int p = _grid[y, x] * _grid[y, x + 1] * _grid[y, x + 2] * _grid[y, x + 3];\n                    if (p > maxProduct) maxProduct = p;\n                }\n                // Vertical (Down)\n                if (y + 3 < size) {\n                    int p = _grid[y, x] * _grid[y + 1, x] * _grid[y + 2, x] * _grid[y + 3, x];\n                    if (p > maxProduct) maxProduct = p;\n                }\n                // Diagonal (Down-Right)\n                if (x + 3 < size && y + 3 < size) {\n                    int p = _grid[y, x] * _grid[y + 1, x + 1] * _grid[y + 2, x + 2] * _grid[y + 3, x + 3];\n                    if (p > maxProduct) maxProduct = p;\n                }\n                // Diagonal (Down-Left)\n                if (x - 3 >= 0 && y + 3 < size) {\n                    int p = _grid[y, x] * _grid[y + 1, x - 1] * _grid[y + 2, x - 2] * _grid[y + 3, x - 3];\n                    if (p > maxProduct) maxProduct = p;\n                }\n            }\n        }\n        return maxProduct;\n    }\n}\n"
    },
    {
      "filename": "Problem012.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 12: Highly divisible triangular number.\n/// Finds the value of the first triangle number to have over five hundred divisors.\n/// </summary>\npublic class Problem012 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 12: Highly divisible triangular number.\n    /// Finds the value of the first triangle number to have over five hundred divisors.\n    /// </summary>\n    /// <returns>The first triangle number with over 500 divisors.</returns>\n    public override object Solve() {\n        return FirstTriangleWithDivisors(500);\n    }\n\n    /// <summary>\n    /// Finds the first triangular number that has more than 'limit' divisors.\n    /// </summary>\n    /// <param name=\"limit\">The number of divisors to exceed.</param>\n    /// <returns>The first triangular number with more than 'limit' divisors.</returns>\n    private int FirstTriangleWithDivisors(int limit) {\n        int n = 1;\n        int d = 1;\n\n        while (d <= limit) {\n            n++;\n            int triangleNumber = n * (n + 1) / 2;\n            d = CountDivisors(triangleNumber);\n        }\n        return n * (n + 1) / 2;\n    }\n\n    /// <summary>\n    /// Counts the number of divisors of a number.\n    /// </summary>\n    private int CountDivisors(int number) {\n        int count = 0;\n        int sqrt = (int)Math.Sqrt(number);\n        for (int i = 1; i <= sqrt; i++) {\n            if (number % i == 0) {\n                count += 2;\n            }\n        }\n        if (sqrt * sqrt == number) count--; // Perfect square correction\n        return count;\n    }\n}\n"
    },
    {
      "filename": "Problem013.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "using System.Numerics;\n\nnamespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 13: Large sum.\n/// Finds the first ten digits of the sum of the following one-hundred 50-digit numbers.\n/// </summary>\npublic class Problem013 : Problem {\n    /// <summary>\n    /// The array of one-hundred 50-digit numbers as strings.\n    /// </summary>\n    private readonly string[] _numbers = {\n        \"37107287533902102798797998220837590246510135740250\",\n        \"46376937677490009712648124896970078050417018260538\",\n        \"74324986199524741059474233309513058123726617309629\",\n        \"91942213363574161572522430563301811072406154908250\",\n        \"23067588207539346171171980310421047513778063246676\",\n        \"89261670696623633820136378418383684178734361726757\",\n        \"28112879812849979408065481931592621691275889832738\",\n        \"44274228917432520321923589422876796487670272189318\",\n        \"47451445736001306439091167216856844588711603153276\",\n        \"70386486105843025439939619828917593665686757934951\",\n        \"62176457141856560629502157223196586755079324193331\",\n        \"64906352462741904929101432445813822663347944758178\",\n        \"92575867712330032591263824938584006353004537997210\",\n        \"50654375598162111158507724474679536081748566529885\",\n        \"72211325251464681662846623630321738697153401851499\",\n        \"57655533379833538222661375957017743068506819394544\",\n        \"77048521714548855498394537961048837363616855121019\",\n        \"66851600655129923583660541466185383471017433695220\",\n        \"87437208612696041385365407834057962128565373360372\",\n        \"20123891451592281880394931334934204515916352723053\",\n        \"60096293452718511203582410367489262311747556096505\",\n        \"93760912210035549673535399418430806509457642630248\",\n        \"47105278799713842857908531486749247338173420277312\",\n        \"18484173815329930615637710272062512960784869394885\",\n        \"36980344981220640624075020563867332732424699388839\",\n        \"52907036963450517765271624895476479768285273269062\",\n        \"50371613993437551178056250644360533178004085461879\",\n        \"85469533605209353908595415494371755648588526319693\",\n        \"45722373469899433935712332153591465388399128905468\",\n        \"19224425750437609320600860411601250329130543472846\",\n        \"15662784454680107264564553281908331894156699347890\",\n        \"25959091799667758128945895280436589345705627116922\",\n        \"30477179317953245479612629535891509013244800735154\",\n        \"27909287639659092400927865462056953989596700114228\",\n        \"40599677750138709426593288144761621092702450095970\",\n        \"47724372993925421074173933076545183715827309396179\",\n        \"92603819434326581136227709351786085141112333287154\",\n        \"63104205174594127554909095553181620766185262037121\",\n        \"92088347872159853386995570026366714128640673368759\",\n        \"20850595917424055289162635460717053598415695278645\",\n        \"23593257000563619232488191199344212954930198406051\",\n        \"77045330188636847293337543305572141926697738729158\",\n        \"59769635072178304145529715312826259021936358404509\",\n        \"57752765371055615438545533152119106888362687157922\",\n        \"18855701809968832772531637080843135397123663784196\",\n        \"47468164315269302557036034137248168584863016450413\",\n        \"49929844293418737385248033245648851635860693591129\",\n        \"31139497493068563340426065710839296833871900462978\",\n        \"53313099008561093491910545335689691956041369182577\",\n        \"80795833652297039947363575661148419850289069319320\",\n        \"90867010480331668227441552293994564258284835284168\",\n        \"53550320464991316943610077113902306268297072992445\",\n        \"98438743124346989715102451370212992591602635936059\",\n        \"05895593162606833844933922676735515732119055972131\",\n        \"15091492095679061601733245619912213150257218941293\",\n        \"86334091105953610720365752328613323570651239581780\",\n        \"79402235058864507633658245725164282205877488401861\",\n        \"80320436896279685657803388610744331714736382553711\",\n        \"42615926797879493526955721325159334196752308676577\",\n        \"28014873456926073718916367452936440588166527659744\",\n        \"82622741955746766453959957060306203058499418491413\",\n        \"25647329248414902920615529521326456783038921332014\",\n        \"52526526016834852130386295776099425927741879124363\",\n        \"63501328054736142801819329382846593092242316259336\",\n        \"20309199311981014893433268470886675489066336472021\",\n        \"15019019602325360656469140084499307396005295483182\",\n        \"67880924970994641974724785365670563467361695240265\",\n        \"72267320471583103022195129524077843510580104437669\",\n        \"87482436531387391883714946395553928578761270577626\",\n        \"47375271137189747047526573751697503225215129054762\",\n        \"25146438963205230321118084046340152914183538472418\",\n        \"61715695138634308191759679108418020387604572311223\",\n        \"25816915052309222211763625052168894643343082928722\",\n        \"66850548548895786395524357516762512479743513308377\",\n        \"50353907620023133687725235595335172041353148673981\",\n        \"28260495686834394077745281270007857213728646326029\",\n        \"94187152019939065692691008108033876253616045084953\",\n        \"74120966591041113615040173643176373428943946001151\",\n        \"42616420513289386694644155052745457208781210415383\",\n        \"71449861645213598193261164987629735579146536907091\",\n        \"20162659850130062334856503132337385528393143542289\",\n        \"34552833115770987102835288511730077709493633593011\",\n        \"96455144150727651716552165184021922245347067840540\",\n        \"08436043520182790943234545129352775612285939727010\",\n        \"34795175853419425399720791301691272332620536131169\",\n        \"09061454999788420614135666239553887425994975694869\",\n        \"55508540456621003784178615384680879622672167469958\",\n        \"13754215085327913128649479185435213322131936155547\",\n        \"85295977526643233822100775235683483915909452761209\",\n        \"49626473262838136846848000223721397555581538674963\",\n        \"91295940938079944480967894465191242066127139173578\",\n        \"96483109295265856980619183331670908719625972743167\",\n        \"47077672473854357368161372370762690310713642451363\",\n        \"96605193759512338431306770986604869050985843380507\",\n        \"60336098914851120411739093665376181326462125606637\",\n        \"27598132431016557150915749591296346068250069007519\",\n        \"82811656221543425451067308450949538809751122279131\",\n        \"47672661856722675446522617594918382740236427107786\",\n        \"47491369524186095313494483750518765300543258133612\",\n        \"94954877478589257036400124463460652540881734254194\"\n    };\n\n    /// <summary>\n    /// Solves Project Euler Problem 13: Large sum.\n    /// Finds the first ten digits of the sum of the following one-hundred 50-digit numbers.\n    /// </summary>\n    /// <returns>The first ten digits of the sum.</returns>\n    public override object Solve() {\n        return FirstTenDigitsOfSum();\n    }\n\n    /// <summary>\n    /// Calculates the sum of all numbers and returns the first 10 digits.\n    /// Uses BigInteger to handle the large sum.\n    /// </summary>\n    /// <returns>A string representing the first ten digits of the sum.</returns>\n    private string FirstTenDigitsOfSum() {\n        BigInteger sum = 0;\n        foreach (var number in _numbers) {\n            sum += BigInteger.Parse(number);\n        }\n\n        string sumString = sum.ToString();\n        return sumString.Substring(0, 10);\n    }\n}\n"
    },
    {
      "filename": "Problem014.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "using System.Numerics;\n\nnamespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 14: Longest Collatz sequence.\n/// Finds the starting number, under one million, which produces the longest Collatz chain.\n/// </summary>\npublic class Problem014 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 14: Longest Collatz sequence.\n    /// Finds the starting number, under one million, which produces the longest Collatz chain.\n    /// </summary>\n    /// <returns>The starting number under one million that produces the longest chain.</returns>\n    public override object Solve() {\n        return LongestCollatzChain(1000000);\n    }\n\n    /// <summary>\n    /// Finds the number under 'limit' that generates the longest Collatz sequence.\n    /// Uses caching to store the lengths of previously computed sequences.\n    /// </summary>\n    /// <param name=\"limit\">The upper bound for the starting number.</param>\n    /// <returns>The starting number with the longest chain.</returns>\n    private int LongestCollatzChain(int limit) {\n        int[] cache = new int[limit + 1]; \n        \n        int maxChainLength = 0;\n        int startingNumber = 0;\n\n        for (int i = 1; i < limit; i++) {\n            int length = GetChainLength(i, cache);\n            if (length > maxChainLength) {\n                maxChainLength = length;\n                startingNumber = i;\n            }\n        }\n        return startingNumber;\n    }\n\n    /// <summary>\n    /// Calculates the Collatz chain length for a number n.\n    /// Uses memoization with the 'cache' array.\n    /// </summary>\n    /// <param name=\"n\">The current number in the sequence.</param>\n    /// <param name=\"cache\">The cache array for memoization.</param>\n    /// <returns>The length of the chain starting at n.</returns>\n    private int GetChainLength(long n, int[] cache) {\n        if (n == 1) return 1;\n\n        if (n < cache.Length && cache[n] != 0) {\n            return cache[n];\n        }\n\n        int length;\n        if (n % 2 == 0) {\n            length = 1 + GetChainLength(n / 2, cache);\n        } else {\n            length = 1 + GetChainLength(3 * n + 1, cache);\n        }\n\n        if (n < cache.Length) {\n            cache[n] = length;\n        }\n\n        return length;\n    }\n}\n"
    },
    {
      "filename": "Problem015.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "using System.Numerics;\n\nnamespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 15: Lattice paths.\n/// Finds the number of routes through a 20x20 grid starting in the top left and ending in the bottom right, moving only right and down.\n/// </summary>\npublic class Problem015 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 15: Lattice paths.\n    /// </summary>\n    /// <returns>The number of routes through a 20x20 grid.</returns>\n    public override object Solve() {\n        return LatticePaths(20);\n    }\n\n    /// <summary>\n    /// Calculates the number of lattice paths in an n x n grid.\n    /// The number of paths is given by the central binomial coefficient: (2n choose n).\n    /// </summary>\n    /// <param name=\"n\">The grid size (n x n).</param>\n    /// <returns>The number of paths.</returns>\n    private BigInteger LatticePaths(int n) {\n        return Library.Combinations(2 * n, n);\n    }\n}\n"
    },
    {
      "filename": "Problem016.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "using System.Numerics;\n\nnamespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 16: Power digit sum.\n/// Finds the sum of the digits of the number 2^1000.\n/// </summary>\npublic class Problem016 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 16: Power digit sum.\n    /// Finds the sum of the digits of the number 2^1000.\n    /// </summary>\n    /// <returns>The sum of the digits of 2^1000.</returns>\n    public override object Solve() {\n        return PowerDigitSum(1000);\n    }\n\n    /// <summary>\n    /// Calculates the sum of digits of 2^exponent.\n    /// </summary>\n    /// <param name=\"exponent\">The exponent to raise 2 to.</param>\n    /// <returns>The sum of the digits.</returns>\n    private int PowerDigitSum(int exponent) {\n        BigInteger number = BigInteger.Pow(2, exponent);\n        return Library.SumDigits(number);\n    }\n}\n"
    },
    {
      "filename": "Problem017.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 17: Number letter counts.\n/// Counts the number of letters used to write out the numbers from 1 to 1000 inclusive.\n/// </summary>\npublic class Problem017 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 17: Number letter counts.\n    /// Counts the number of letters used to write out the numbers from 1 to 1000 inclusive.\n    /// </summary>\n    /// <returns>The total number of letters used.</returns>\n    public override object Solve() {\n        return NumberLetterCounts();\n    }\n\n    /// <summary>\n    /// Calculates the total letters needed to write numbers from 1 to 1000.\n    /// Counts are based on British usage (e.g., \"one hundred and forty-two\").\n    /// </summary>\n    /// <returns>Total letter count.</returns>\n    private int NumberLetterCounts() {\n        int[] digitsLength = { 0, 3, 3, 5, 4, 4, 3, 5, 5, 4 };\n        int[] teensLength = { 3, 6, 6, 8, 8, 7, 7, 9, 8, 8 };\n        int[] tensLength = { 0, 0, 6, 6, 5, 5, 5, 7, 6, 6 }; \n\n        int digits = digitsLength.Sum();\n        int teens = teensLength.Sum();\n        int tens = tensLength.Sum();\n        \n        int hundred = 7;\n        int and = 3;\n        int oneThousand = 11;\n\n        int oneToNinetyNine = digits + teens + (tens * 10) + (digits * 8);\n        int hundredsPart = digits * 100 + hundred * 900 + and * (9 * 99) + oneToNinetyNine * 9;\n        \n        return oneToNinetyNine + hundredsPart + oneThousand;\n    }\n}\n"
    },
    {
      "filename": "Problem018.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 18: Maximum path sum I.\n/// Finds the maximum total from top to bottom of the triangle.\n/// </summary>\npublic class Problem018 : Problem {\n    /// <summary>\n    /// Represents the triangle of numbers.\n    /// </summary>\n    private readonly List<int[]> _triangle = [\n        new[] { 75 },\n        new[] { 95, 64 },\n        new[] { 17, 47, 82 },\n        new[] { 18, 35, 87, 10 },\n        new[] { 20, 04, 82, 47, 65 },\n        new[] { 19, 01, 23, 75, 03, 34 },\n        new[] { 88, 02, 77, 73, 07, 63, 67 },\n        new[] { 99, 65, 04, 28, 06, 16, 70, 92 },\n        new[] { 41, 41, 26, 56, 83, 40, 80, 70, 33 },\n        new[] { 41, 48, 72, 33, 47, 32, 37, 16, 94, 29 },\n        new[] { 53, 71, 44, 65, 25, 43, 91, 52, 97, 51, 14 },\n        new[] { 70, 11, 33, 28, 77, 73, 17, 78, 39, 68, 17, 57 },\n        new[] { 91, 71, 52, 38, 17, 14, 91, 43, 58, 50, 27, 29, 48 },\n        new[] { 63, 66, 04, 68, 89, 53, 67, 30, 73, 16, 69, 87, 40, 31 },\n        new[] { 04, 62, 98, 27, 23, 09, 70, 98, 73, 93, 38, 53, 60, 04, 23 }\n    ];\n\n    /// <summary>\n    /// Solves Project Euler Problem 18: Maximum path sum I.\n    /// </summary>\n    /// <returns>The maximum path sum.</returns>\n    public override object Solve() {\n        return MaxPathSum();\n    }\n\n    /// <summary>\n    /// Calculates the maximum path sum using dynamic programming.\n    /// Modifies a copy of the triangle, processing from bottom to top.\n    /// </summary>\n    /// <returns>The maximum path sum.</returns>\n    private int MaxPathSum() {\n        var triangleCopy = _triangle.Select(a => (int[])a.Clone()).ToList();\n\n        for (int i = triangleCopy.Count - 2; i >= 0; i--) {\n            for (int j = 0; j < triangleCopy[i].Length; j++) {\n                triangleCopy[i][j] += Math.Max(triangleCopy[i + 1][j], triangleCopy[i + 1][j + 1]);\n            }\n        }\n        return triangleCopy[0][0];\n    }\n}\n"
    },
    {
      "filename": "Problem019.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 19: Counting Sundays.\n/// Calculates how many Sundays fell on the first of the month during the twentieth century.\n/// </summary>\npublic class Problem019 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 19: Counting Sundays.\n    /// </summary>\n    /// <returns>The total number of Sundays that fell on the first of a month (1901-2000).</returns>\n    public override object Solve() {\n        return NumberOfSundays();\n    }\n\n    /// <summary>\n    /// Counts Sundays on the 1st of the month.\n    /// </summary>\n    private int NumberOfSundays() {\n        int sundays = 0;\n        int dayOfWeek = 2; // 1 Jan 1901 was Tuesday\n\n        for (int year = 1901; year <= 2000; year++) {\n            for (int month = 1; month <= 12; month++) {\n                if (dayOfWeek == 0) sundays++;\n                dayOfWeek = (dayOfWeek + GetNumberOfDays(month, year)) % 7;\n            }\n        }\n        return sundays;\n    }\n\n    /// <summary>\n    /// Returns number of days in a month.\n    /// </summary>\n    private int GetNumberOfDays(int month, int year) {\n        if (month == 4 || month == 6 || month == 9 || month == 11) return 30;\n        if (month == 2) return IsLeapYear(year) ? 29 : 28;\n        return 31;\n    }\n\n    /// <summary>\n    /// Checks if a year is a leap year.\n    /// </summary>\n    private bool IsLeapYear(int year) {\n        return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\n    }\n}\n"
    },
    {
      "filename": "Problem020.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 20: Factorial digit sum.\n/// Finds the sum of the digits in the number 100!\n/// </summary>\npublic class Problem020 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 20: Factorial digit sum.\n    /// </summary>\n    /// <returns>The sum of the digits of 100!.</returns>\n    public override object Solve() {\n        return FactorialDigitSum();\n    }\n\n    /// <summary>\n    /// Calculates the sum of digits of 100 factorial.\n    /// </summary>\n    private int FactorialDigitSum() {\n        var factorial = Library.Factorial(100);\n        return Library.SumDigits(factorial);\n    }\n}\n"
    },
    {
      "filename": "Problem021.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 21: Amicable numbers.\n/// Finds the sum of all the amicable numbers under 10000.\n/// </summary>\npublic class Problem021 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 21: Amicable numbers.\n    /// </summary>\n    /// <returns>The sum of all amicable numbers under 10000.</returns>\n    public override object Solve() {\n        return SumAmicableNumbers(10000);\n    }\n\n    /// <summary>\n    /// Calculates the sum of all amicable numbers under the given limit.\n    /// Uses a cache for divisor sums.\n    /// </summary>\n    private int SumAmicableNumbers(int limit) {\n        int[] d = new int[limit];\n        // Calculate d(n) for all n < limit\n        for (int i = 1; i < limit; i++) {\n            d[i] = SumProperDivisors(i);\n        }\n\n        int sum = 0;\n        for (int a = 2; a < limit; a++) {\n            int b = d[a];\n            if (b > a && b < limit && d[b] == a) {\n                sum += a + b;\n            }\n        }\n        return sum;\n    }\n\n    /// <summary>\n    /// Calculates sum of proper divisors of n.\n    /// </summary>\n    private int SumProperDivisors(int n) {\n        int sum = 1;\n        int sqrt = (int)Math.Sqrt(n);\n        for (int i = 2; i <= sqrt; i++) {\n            if (n % i == 0) {\n                sum += i;\n                if (i * i != n) sum += n / i;\n            }\n        }\n        return sum;\n    }\n}\n"
    },
    {
      "filename": "Problem022.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 22: Names scores.\n/// Calculates the total of all the name scores in the file.\n/// </summary>\npublic class Problem022 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 22: Names scores.\n    /// </summary>\n    /// <returns>The total name score of the file.</returns>\n    public override object Solve() {\n        return CalculateNameScores();\n    }\n\n    /// <summary>\n    /// Reads names, sorts them, and computes the total score.\n    /// </summary>\n    private long CalculateNameScores() {\n        List<string> names = Library.ReadFile(\"names.txt\");\n        names.Sort();\n\n        long totalScore = 0;\n        for (int i = 0; i < names.Count; i++) {\n            int nameValue = 0;\n            foreach (char c in names[i]) {\n                nameValue += c - 'A' + 1;\n            }\n            totalScore += (long)nameValue * (i + 1);\n        }\n        return totalScore;\n    }\n}\n"
    },
    {
      "filename": "Problem023.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 23: Non-abundant sums.\n/// Finds the sum of all positive integers which cannot be written as the sum of two abundant numbers.\n/// </summary>\npublic class Problem023 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 23: Non-abundant sums.\n    /// </summary>\n    /// <returns>The sum of all positive integers which cannot be written as the sum of two abundant numbers.</returns>\n    public override object Solve() {\n        return SumNonAbundantSums();\n    }\n\n    /// <summary>\n    /// Finds sum of non-abundant sums.\n    /// </summary>\n    private int SumNonAbundantSums() {\n        const int limit = 28123;\n        List<int> abundantNumbers = new List<int>();\n        \n        // Find all abundant numbers\n        for (int i = 12; i <= limit; i++) {\n            if (IsAbundant(i)) {\n                abundantNumbers.Add(i);\n            }\n        }\n\n        bool[] canBeWrittenAsAbundantSum = new bool[limit + 1];\n        for (int i = 0; i < abundantNumbers.Count; i++) {\n            for (int j = i; j < abundantNumbers.Count; j++) {\n                int sum = abundantNumbers[i] + abundantNumbers[j];\n                if (sum <= limit) {\n                    canBeWrittenAsAbundantSum[sum] = true;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        int totalSum = 0;\n        for (int i = 1; i <= limit; i++) {\n            if (!canBeWrittenAsAbundantSum[i]) {\n                totalSum += i;\n            }\n        }\n        return totalSum;\n    }\n\n    /// <summary>\n    /// Checks if a number is abundant (sum of proper divisors > n).\n    /// </summary>\n    private bool IsAbundant(int n) {\n        return Library.CreateDivisorSumCache(n).GetDivisorSum(n) > n;\n    }\n}\n"
    },
    {
      "filename": "Problem024.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 24: Lexicographic permutations.\n/// Finds the millionth lexicographic permutation of the digits 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9.\n/// </summary>\npublic class Problem024 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 24: Lexicographic permutations.\n    /// </summary>\n    /// <returns>The millionth lexicographic permutation.</returns>\n    public override object Solve() {\n        return NthLexicalPermutation(1000000);\n    }\n\n    /// <summary>\n    /// Finds the Nth lexicographic permutation using factoradic system.\n    /// </summary>\n    private string NthLexicalPermutation(ulong targetPermutationIndex) {\n        var availableDigits = new List<char>(\"0123456789\".ToCharArray());\n        var resultPermutation = new char[10];\n\n        ulong currentIndex = targetPermutationIndex - 1;\n        int numDigits = availableDigits.Count;\n\n        for (int i = 0; i < numDigits; i++) {\n            int remainingDigitsToPlace = numDigits - 1 - i; \n            ulong factorialOfRemaining = (ulong)Library.Factorial(remainingDigitsToPlace); \n\n            int digitIndexInList = (int)(currentIndex / factorialOfRemaining);\n            resultPermutation[i] = availableDigits[digitIndexInList];\n            availableDigits.RemoveAt(digitIndexInList);\n            currentIndex %= factorialOfRemaining;\n        }\n\n        return new string(resultPermutation);\n    }\n}\n"
    },
    {
      "filename": "Problem025.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 25: 1000-digit Fibonacci number.\n/// Finds the index of the first term in the Fibonacci sequence to contain 1000 digits.\n/// </summary>\npublic class Problem025 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 25: 1000-digit Fibonacci number.\n    /// </summary>\n    /// <returns>The index of the first term in the Fibonacci sequence to contain 1000 digits.</returns>\n    public override object Solve() {\n        return FibonacciNDigits(1000);\n    }\n\n    /// <summary>\n    /// Finds index of first Fib number with n digits using Binet's formula approximation.\n    /// </summary>\n    private int FibonacciNDigits(int numDigits) {\n        if (numDigits <= 1) return 1;\n\n        double phi = (1 + Math.Sqrt(5)) / 2.0;\n        double log10Phi = Math.Log10(phi);\n        double log10Sqrt5 = Math.Log10(Math.Sqrt(5));\n\n        int index = 2;\n        while (true) {\n            double logFib = index * log10Phi - log10Sqrt5;\n            int currentDigitCount = (int)Math.Floor(logFib) + 1;\n\n            if (currentDigitCount >= numDigits) {\n                break;\n            }\n            index++;\n        }\n        return index;\n    }\n}\n"
    },
    {
      "filename": "Problem026.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 26: Reciprocal cycles.\n/// Finds the value of d &lt; 1000 for which 1/d contains the longest recurring cycle in its decimal fraction part.\n/// </summary>\npublic class Problem026 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 26: Reciprocal cycles.\n    /// </summary>\n    /// <returns>The value of d &lt; 1000 with longest recurring cycle.</returns>\n    public override object Solve() {\n        return GetLongestCycleDenominator(1000);\n    }\n\n    /// <summary>\n    /// Finds d with longest cycle.\n    /// </summary>\n    private int GetLongestCycleDenominator(int limit) {\n        int maxCycleLength = 0;\n        int denominatorWithMaxCycle = 0;\n\n        for (int d = limit - 1; d >= 2; d--) {\n            if (maxCycleLength >= d) {\n                break;\n            }\n\n            if (d % 2 == 0 || d % 5 == 0 || !Library.IsPrime(d)) {\n                continue;\n            }\n\n            int cycleLength = GetCycleLength(d);\n            if (cycleLength > maxCycleLength) { \n                maxCycleLength = cycleLength;\n                denominatorWithMaxCycle = d;\n            }\n        }\n        return denominatorWithMaxCycle;\n    }\n\n    /// <summary>\n    /// Calculates cycle length of 1/d.\n    /// </summary>\n    private int GetCycleLength(int d) {\n        if (d <= 1) {\n            throw new ArgumentOutOfRangeException(nameof(d), \"Denominator must be greater than 1.\");\n        }\n\n        int remainder = 1; \n        int position = 0;\n\n        do {\n            remainder = (remainder * 10) % d; \n            position++;                       \n        } while (remainder != 1 && remainder != 0);\n\n        return remainder == 0 ? 0 : position;\n    }\n}\n"
    },
    {
      "filename": "Problem027.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 27: Quadratic primes.\n/// Finds the product of coefficients a and b for the quadratic expression n^2 + an + b that produces the maximum number of primes.\n/// </summary>\npublic class Problem027 : Problem {\n    private const int Limit = 1000;\n    private const int SieveLimit = 100000;\n    private readonly bool[] _isPrime;\n\n    /// <summary>\n    /// Initializes a new instance of the <see cref=\"Problem027\"/> class.\n    /// </summary>\n    public Problem027() {\n        _isPrime = Library.SieveOfEratosthenesBoolArray(SieveLimit);\n    }\n\n    /// <summary>\n    /// Solves Project Euler Problem 27: Quadratic primes.\n    /// </summary>\n    /// <returns>The product of coefficients a and b.</returns>\n    public override object Solve() {\n        return CoefficientProduct(Limit);\n    }\n\n    /// <summary>\n    /// Finds product a*b.\n    /// </summary>\n    private int CoefficientProduct(int coeffLimit) {\n        int bestA = 0, bestB = 0, maxLength = 0;\n\n        for (int b = 3; b < coeffLimit; b += 2) {\n            if (b >= _isPrime.Length || !_isPrime[b]) {\n                continue;\n            }\n\n            for (int a = -coeffLimit + 1; a < coeffLimit; a += 2) {\n                int n = 0;\n                while (true) {\n                    int val = n * n + a * n + b;\n                    if (val < 0 || val >= SieveLimit || !_isPrime[val]) {\n                        break; \n                    }\n                    n++; \n                }\n\n                if (n > maxLength) { \n                    maxLength = n;\n                    bestA = a;\n                    bestB = b;\n                }\n            }\n        }\n        return bestA * bestB;\n    }\n}\n"
    },
    {
      "filename": "Problem028.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 28: Number spiral diagonals.\n/// Finds the sum of the numbers on the diagonals in a 1001 by 1001 spiral.\n/// </summary>\npublic class Problem028 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 28: Number spiral diagonals.\n    /// </summary>\n    /// <returns>The sum of the numbers on the diagonals.</returns>\n    public override object Solve() {\n        return SpiralSum(1001); \n    }\n\n    /// <summary>\n    /// Calculates diagonal sum for size n x n spiral.\n    /// </summary>\n    private int SpiralSum(int size) {\n        if (size <= 0 || size % 2 == 0) {\n            throw new ArgumentException(\"Size must be an odd positive integer.\", nameof(size));\n        }\n        if (size == 1) {\n            return 1; \n        }\n\n        int currentNumber = 1; \n        int step = 2;          \n        int sumOfDiagonals = 1; \n        int cornersInCurrentRing = 0; \n\n        while (currentNumber < size * size) {\n            currentNumber += step; \n            sumOfDiagonals += currentNumber;\n            cornersInCurrentRing++;\n\n            if (cornersInCurrentRing == 4) {\n                step += 2;             \n                cornersInCurrentRing = 0; \n            }\n        }\n        return sumOfDiagonals;\n    }\n}\n"
    },
    {
      "filename": "Problem029.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 29: Distinct powers.\n/// Finds the number of distinct terms in the sequence generated by a^b for 2 &lt;= a &lt;= 100 and 2 &lt;= b &lt;= 100.\n/// </summary>\npublic class Problem029 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 29: Distinct powers.\n    /// </summary>\n    /// <returns>The number of distinct terms.</returns>\n    public override object Solve() {\n        return DistinctPowers();\n    }\n\n    /// <summary>\n    /// Calculates count of distinct powers a^b.\n    /// </summary>\n    private long DistinctPowers() {\n        long result = 0;\n\n        const int noSquare = 81 * 99; \n        const int noThird = 4 * (99 + 50); \n\n        int thirdPowers = 0;  \n        int fourthPowers = 0; \n        int fifthPowers = 0;\n        int sixthPowers = 0;\n\n        for (int i = 2; i <= 100; i++) {\n            int n = i * 3; \n            if (n > 100 && \n                (n > 200 || n % 2 != 0)) \n                thirdPowers++;\n\n            n = i * 4;\n            if (n > 200 &&\n                (n > 300 || n % 3 != 0))\n                fourthPowers++;\n\n            n = i * 5;\n            if (n > 100 &&\n                (n > 200 || n % 2 != 0) &&\n                (n > 300 || n % 3 != 0) &&\n                (n > 400 || n % 4 != 0))\n                fifthPowers++;\n\n            n = i * 6;\n            if (n > 100 &&\n                (n > 200 || n % 2 != 0) &&\n                (n > 300 || n % 3 != 0) &&\n                (n > 400 || n % 4 != 0) &&\n                (n > 500 || n % 5 != 0))\n                sixthPowers++;\n        }\n\n        result += 99 + 50 + thirdPowers + fourthPowers + noSquare + noThird;\n        result += 99 + 50 + thirdPowers + fourthPowers + fifthPowers + sixthPowers;\n\n        return result; \n    }\n}\n"
    },
    {
      "filename": "Problem030.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 30: Digit fifth powers.\n/// Finds the sum of all numbers that can be written as the sum of the fifth powers of their digits.\n/// </summary>\npublic class Problem030 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 30: Digit fifth powers.\n    /// </summary>\n    /// <returns>The sum of all numbers that are equal to the sum of the fifth powers of their digits.</returns>\n    public override object Solve() {\n        return SumAllFifthPowers();\n    }\n\n    /// <summary>\n    /// Finds sum of numbers equal to sum of fifth powers of digits.\n    /// </summary>\n    private long SumAllFifthPowers() {\n        long[] powers = new long[10];\n        long[] diffs = new long[9];\n        int[] digits = new int[100];\n\n        for (int i = 0; i < 10; i++) {\n            powers[i] = 1;\n            for (int j = 0; j < 5; j++) powers[i] *= i; \n        }\n\n        for (int i = 0; i < 9; i++) diffs[i] = powers[i + 1] - powers[i];\n\n        long totalSumOfMatchingNumbers = 0; \n        long currentSumOfDigitPowers = 1;   \n        long currentNumberValue = 1;        \n        int currentNumDigits = 0;           \n        digits[currentNumDigits] = 1;       \n\n        while (true) {\n            int[] digitCounts = new int[10]; \n            for (int i = 0; i <= currentNumDigits; i++) {\n                digitCounts[digits[i]]++;\n            }\n\n            long tempSumPow = currentSumOfDigitPowers;\n            while (tempSumPow > 0) {\n                digitCounts[(int)(tempSumPow % 10)]--; \n                tempSumPow /= 10;\n            }\n\n            int checkAnagram;\n            for (checkAnagram = 0; checkAnagram < 10; checkAnagram++) { \n                if (digitCounts[checkAnagram] != 0) {\n                    break;\n                }\n            }\n            \n            if (checkAnagram == 10 && currentNumDigits > 0) { \n                totalSumOfMatchingNumbers += currentSumOfDigitPowers;\n            }\n\n            if (currentNumberValue < 354294 && (currentNumberValue * 10 + digits[currentNumDigits] <= currentSumOfDigitPowers + powers[9])) { \n                currentNumDigits++;\n                digits[currentNumDigits] = digits[currentNumDigits-1]; \n                currentNumberValue = currentNumberValue * 10 + digits[currentNumDigits];\n                currentSumOfDigitPowers += powers[digits[currentNumDigits]];\n            } else {\n                while (currentNumDigits >= 0 && digits[currentNumDigits] == 9) { \n                    currentSumOfDigitPowers -= powers[9]; \n                    digits[currentNumDigits] = 0; \n                    currentNumDigits--;\n                    currentNumberValue /= 10;\n                }\n\n                if (currentNumDigits < 0) { \n                    break;\n                }\n\n                currentNumberValue++; \n                currentSumOfDigitPowers -= powers[digits[currentNumDigits]]; \n                digits[currentNumDigits]++;                                  \n                currentSumOfDigitPowers += powers[digits[currentNumDigits]]; \n            }\n        }\n        return totalSumOfMatchingNumbers;\n    }\n}\n"
    },
    {
      "filename": "Problem031.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 31: Coin sums.\n/// Finds the number of different ways \u00a32 can be made using any number of coins.\n/// </summary>\npublic class Problem031 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 31: Coin sums.\n    /// </summary>\n    /// <returns>The number of ways to make \u00a32.</returns>\n    public override object Solve() {\n        return CoinSums(200);\n    }\n\n    /// <summary>\n    /// Calculates the number of ways to make 'target' pence using UK coins.\n    /// Uses dynamic programming.\n    /// </summary>\n    private int CoinSums(int target) {\n        int[] coins = { 1, 2, 5, 10, 20, 50, 100, 200 };\n        int[] ways = new int[target + 1];\n        ways[0] = 1;\n\n        foreach (int coin in coins) {\n            for (int j = coin; j <= target; j++) {\n                ways[j] += ways[j - coin];\n            }\n        }\n        return ways[target];\n    }\n}\n"
    },
    {
      "filename": "Problem032.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 32: Pandigital products.\n/// Finds the sum of all products whose multiplicand/multiplier/product identity can be written as a 1 through 9 pandigital.\n/// </summary>\npublic class Problem032 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 32: Pandigital products.\n    /// </summary>\n    /// <returns>The sum of all pandigital products.</returns>\n    public override object Solve() {\n        return SumPandigitalProducts();\n    }\n\n    /// <summary>\n    /// Finds sum of unique products.\n    /// </summary>\n    private int SumPandigitalProducts() {\n        HashSet<int> products = new HashSet<int>();\n\n        for (int a = 1; a < 10; a++) {\n            for (int b = 1234; b < 9876; b++) {\n                int p = a * b;\n                if (p > 9876) break;\n                if (IsPandigitalProduct(a, b, p)) products.Add(p);\n            }\n        }\n\n        for (int a = 12; a < 99; a++) {\n            for (int b = 123; b < 987; b++) {\n                int p = a * b;\n                if (p > 9876) break;\n                if (IsPandigitalProduct(a, b, p)) products.Add(p);\n            }\n        }\n\n        return products.Sum();\n    }\n\n    /// <summary>\n    /// Checks if concatenation of a, b, p is 1-9 pandigital.\n    /// </summary>\n    private bool IsPandigitalProduct(int a, int b, int p) {\n        string s = $\"{a}{b}{p}\";\n        return Library.IsPandigital(s);\n    }\n}\n"
    },
    {
      "filename": "Problem033.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 33: Digit cancelling fractions.\n/// Finds the denominator of the product of the four non-trivial examples.\n/// </summary>\npublic class Problem033 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 33: Digit cancelling fractions.\n    /// </summary>\n    /// <returns>The denominator of the product of the fractions.</returns>\n    public override object Solve() {\n        return DigitCancellingFractions();\n    }\n\n    /// <summary>\n    /// Finds fractions where cancelling a digit gives correct simplified value.\n    /// </summary>\n    private int DigitCancellingFractions() {\n        int numProduct = 1;\n        int denProduct = 1;\n\n        for (int den = 11; den < 100; den++) {\n            for (int num = 10; num < den; num++) {\n                int n0 = num % 10;\n                int n1 = num / 10;\n                int d0 = den % 10;\n                int d1 = den / 10;\n\n                if (n0 == 0 && d0 == 0) continue;\n\n                if (n0 == d1 && (double)n1 / d0 == (double)num / den) {\n                    numProduct *= num;\n                    denProduct *= den;\n                } else if (n1 == d0 && (double)n0 / d1 == (double)num / den) {\n                    numProduct *= num;\n                    denProduct *= den;\n                }\n            }\n        }\n        \n        return denProduct / Library.Gcd(numProduct, denProduct);\n    }\n}\n"
    },
    {
      "filename": "Problem034.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 34: Digit factorials.\n/// Finds the sum of all numbers which are equal to the sum of the factorial of their digits.\n/// </summary>\npublic class Problem034 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 34: Digit factorials.\n    /// </summary>\n    /// <returns>The sum of all numbers equal to the sum of the factorial of their digits.</returns>\n    public override object Solve() {\n        return SumDigitFactorials();\n    }\n\n    /// <summary>\n    /// Finds sum of numbers equal to sum of digit factorials.\n    /// </summary>\n    private int SumDigitFactorials() {\n        int[] factorials = new int[10];\n        for (int i = 0; i < 10; i++) factorials[i] = Library.IntFactorial(i);\n\n        int totalSum = 0;\n        for (int i = 10; i < 2540161; i++) {\n            int sumOfFacts = 0;\n            int temp = i;\n            while (temp > 0) {\n                sumOfFacts += factorials[temp % 10];\n                temp /= 10;\n            }\n\n            if (sumOfFacts == i) {\n                totalSum += i;\n            }\n        }\n        return totalSum;\n    }\n}\n"
    },
    {
      "filename": "Problem035.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 35: Circular primes.\n/// Finds the number of circular primes below one million.\n/// </summary>\npublic class Problem035 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 35: Circular primes.\n    /// </summary>\n    /// <returns>The number of circular primes below one million.</returns>\n    public override object Solve() {\n        return CountCircularPrimes(1000000);\n    }\n\n    /// <summary>\n    /// Counts circular primes.\n    /// </summary>\n    private int CountCircularPrimes(int limit) {\n        var isPrime = Library.SieveOfEratosthenesBoolArray(limit);\n        int count = 0;\n\n        for (int i = 2; i < limit; i++) {\n            if (isPrime[i]) {\n                if (IsCircularPrime(i, isPrime)) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    /// <summary>\n    /// Checks if a number is a circular prime.\n    /// </summary>\n    private bool IsCircularPrime(int n, bool[] isPrime) {\n        string s = n.ToString();\n        int len = s.Length;\n        \n        for (int i = 0; i < len; i++) {\n            int rem = n % 10;\n            n = n / 10 + rem * Library.Pow10(len - 1);\n            if (!isPrime[n]) return false;\n        }\n        return true;\n    }\n}\n"
    },
    {
      "filename": "Problem036.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 36: Double-base palindromes.\n/// Finds the sum of all numbers, less than one million, which are palindromic in base 10 and base 2.\n/// </summary>\npublic class Problem036 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 36: Double-base palindromes.\n    /// </summary>\n    /// <returns>The sum of all double-base palindromes.</returns>\n    public override object Solve() {\n        return SumDoubleBasePalindromes(1000000);\n    }\n\n    /// <summary>\n    /// Finds sum of numbers palindromic in base 10 and base 2.\n    /// </summary>\n    private int SumDoubleBasePalindromes(int limit) {\n        int sum = 0;\n        for (int i = 1; i < limit; i++) { \n            if (i % 2 == 0) continue; \n            \n            if (Library.IsPalindrome(i)) {\n                string binary = Convert.ToString(i, 2);\n                if (Library.IsPalindrome(binary)) {\n                    sum += i;\n                }\n            }\n        }\n        return sum;\n    }\n}\n"
    },
    {
      "filename": "Problem037.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 37: Truncatable primes.\n/// Finds the sum of the only eleven primes that are both truncatable from left to right and right to left.\n/// </summary>\npublic class Problem037 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 37: Truncatable primes.\n    /// </summary>\n    /// <returns>The sum of the eleven truncatable primes.</returns>\n    public override object Solve() {\n        return SumTruncatablePrimes();\n    }\n\n    /// <summary>\n    /// Finds sum of truncatable primes.\n    /// </summary>\n    private int SumTruncatablePrimes() {\n        int count = 0;\n        int sum = 0;\n        int n = 11; \n\n        while (count < 11) {\n            if (Library.IsPrime(n) && IsTruncatable(n)) {\n                count++;\n                sum += n;\n            }\n            n += 2;\n        }\n        return sum;\n    }\n\n    /// <summary>\n    /// Checks if a prime is truncatable.\n    /// </summary>\n    private bool IsTruncatable(int n) {\n        int temp = n;\n        while (temp > 0) {\n            if (!Library.IsPrime(temp)) return false;\n            temp /= 10;\n        }\n\n        temp = n;\n        int digits = Library.DigitCount(n);\n        int divisor = Library.Pow10(digits - 1);\n        \n        while (divisor > 1) { \n            temp %= divisor;\n            if (!Library.IsPrime(temp)) return false;\n            divisor /= 10;\n        }\n        \n        return true;\n    }\n}\n"
    },
    {
      "filename": "Problem038.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 38: Pandigital multiples.\n/// Finds the largest 1 to 9 pandigital 9-digit number that can be formed as the concatenated product of an integer with (1,2, ... , n) where n > 1.\n/// </summary>\npublic class Problem038 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 38: Pandigital multiples.\n    /// </summary>\n    /// <returns>The largest 1-9 pandigital 9-digit number.</returns>\n    public override object Solve() {\n        return LargestPandigitalMultiple();\n    }\n\n    /// <summary>\n    /// Finds largest pandigital multiple.\n    /// </summary>\n    private int LargestPandigitalMultiple() {\n        int maxPandigital = 0;\n\n        for (int x = 1; x < 10000; x++) {\n            string s = \"\";\n            int n = 1;\n            while (s.Length < 9) {\n                s += (x * n).ToString();\n                n++;\n            }\n\n            if (s.Length == 9 && Library.IsPandigital(s)) {\n                int val = int.Parse(s);\n                if (val > maxPandigital) maxPandigital = val;\n            }\n        }\n        return maxPandigital;\n    }\n}\n"
    },
    {
      "filename": "Problem039.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 39: Integer right triangles.\n/// Finds the value of p &lt;= 1000 for which the number of solutions is maximised.\n/// </summary>\npublic class Problem039 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 39: Integer right triangles.\n    /// </summary>\n    /// <returns>The perimeter p &lt;= 1000 with max solutions.</returns>\n    public override object Solve() {\n        return MaxRightTrianglesPerimeter();\n    }\n\n    /// <summary>\n    /// Finds p with max integer right triangles.\n    /// </summary>\n    private int MaxRightTrianglesPerimeter() {\n        int maxSolutions = 0;\n        int bestP = 0;\n\n        for (int p = 1; p <= 1000; p++) {\n            int solutions = 0;\n            for (int a = 1; a < p / 3; a++) {\n                if ((p * (p - 2 * a)) % (2 * (p - a)) == 0) {\n                    solutions++;\n                }\n            }\n            if (solutions > maxSolutions) {\n                maxSolutions = solutions;\n                bestP = p;\n            }\n        }\n        return bestP;\n    }\n}\n"
    },
    {
      "filename": "Problem040.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 40: Champernowne's constant.\n/// Finds the value of the expression d1 * d10 * d100 * d1000 * d10000 * d100000 * d1000000.\n/// </summary>\npublic class Problem040 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 40: Champernowne's constant.\n    /// </summary>\n    /// <returns>The product of the specified digits.</returns>\n    public override object Solve() {\n        return CalculateDigitProduct();\n    }\n\n    /// <summary>\n    /// Calculates product of digits at indices 1, 10, 100, etc.\n    /// </summary>\n    private long CalculateDigitProduct() {\n        long product = 1;\n        for (int position = 1; position <= 1000000; position *= 10) {\n            product *= FindNthDigitInChampernowneConstant(position);\n        }\n        return product;\n    }\n\n    /// <summary>\n    /// Finds the nth digit of Champernowne's constant.\n    /// </summary>\n    private int FindNthDigitInChampernowneConstant(int nthPosition) {\n        int digitsInCurrentBlockLength = 1;\n        long numbersInBlock = 9;\n        long startNumberInBlock = 1;\n\n        while (nthPosition > digitsInCurrentBlockLength * numbersInBlock) {\n            nthPosition -= (int)(digitsInCurrentBlockLength * numbersInBlock);\n            digitsInCurrentBlockLength++;\n            numbersInBlock *= 10;\n            startNumberInBlock *= 10;\n        }\n\n        long targetNumber = startNumberInBlock + (nthPosition - 1) / digitsInCurrentBlockLength;\n        int digitIndexFromLeft = (nthPosition - 1) % digitsInCurrentBlockLength;\n\n        int digitsToRemoveFromRight = digitsInCurrentBlockLength - 1 - digitIndexFromLeft;\n        for (int i = 0; i < digitsToRemoveFromRight; i++) {\n            targetNumber /= 10;\n        }\n        return (int)(targetNumber % 10);\n    }\n}\n"
    },
    {
      "filename": "Problem041.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 41: Pandigital prime.\n/// Finds the largest n-digit pandigital prime that exists.\n/// </summary>\npublic class Problem041 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 41: Pandigital prime.\n    /// </summary>\n    /// <returns>The largest n-digit pandigital prime.</returns>\n    public override object Solve() {\n        return LargestPandigitalPrime();\n    }\n\n    /// <summary>\n    /// Finds largest pandigital prime.\n    /// </summary>\n    private int LargestPandigitalPrime() {\n        int maxPrime = 0;\n        int[] ascDigits = { 1, 2, 3, 4, 5, 6, 7 };\n        \n        do {\n            int num = DigitsToInt(ascDigits);\n            if (Library.IsPrime(num)) {\n                if (num > maxPrime) maxPrime = num;\n            }\n        } while (Library.Permute(ascDigits));\n        \n        if (maxPrime > 0) return maxPrime;\n\n        int[] ascDigits4 = { 1, 2, 3, 4 };\n        do {\n            int num = DigitsToInt(ascDigits4);\n            if (Library.IsPrime(num)) {\n                if (num > maxPrime) maxPrime = num;\n            }\n        } while (Library.Permute(ascDigits4));\n\n        return maxPrime;\n    }\n\n    private int DigitsToInt(int[] digits) {\n        int n = 0;\n        foreach (int d in digits) {\n            n = n * 10 + d;\n        }\n        return n;\n    }\n}\n"
    },
    {
      "filename": "Problem042.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 42: Coded triangle numbers.\n/// Counts how many words in a file are triangle numbers.\n/// </summary>\npublic class Problem042 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 42: Coded triangle numbers.\n    /// </summary>\n    /// <returns>The count of triangle words.</returns>\n    public override object Solve() {\n        return CountTriangleWords();\n    }\n\n    /// <summary>\n    /// Counts words whose value is a triangular number.\n    /// </summary>\n    private int CountTriangleWords() {\n        List<string> words = Library.ReadFile(\"words.txt\");\n        int count = 0;\n        foreach (string word in words) {\n            if (IsTriangleWord(word)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    /// <summary>\n    /// Checks if a word is a triangle word.\n    /// </summary>\n    private bool IsTriangleWord(string word) {\n        int value = 0;\n        foreach (char c in word) {\n            value += c - 'A' + 1;\n        }\n        return Library.IsTriangular(value);\n    }\n}\n"
    },
    {
      "filename": "Problem043.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 43: Sub-string divisibility.\n/// Finds the sum of all 0 to 9 pandigital numbers with a specific sub-string divisibility property.\n/// </summary>\npublic class Problem043 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 43: Sub-string divisibility.\n    /// </summary>\n    /// <returns>The sum of all numbers with the property.</returns>\n    public override object Solve() {\n        return SumSubStringDivisible();\n    }\n\n    /// <summary>\n    /// Finds sum of 0-9 pandigital numbers satisfying divisibility rules.\n    /// </summary>\n    private long SumSubStringDivisible() {\n        int[] digits = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n        long sum = 0;\n        int[] divisors = { 2, 3, 5, 7, 11, 13, 17 };\n\n        do {\n            if (digits[0] == 0) continue; \n            \n            bool ok = true;\n            for (int i = 0; i < 7; i++) {\n                int n = digits[i + 1] * 100 + digits[i + 2] * 10 + digits[i + 3];\n                if (n % divisors[i] != 0) {\n                    ok = false;\n                    break;\n                }\n            }\n\n            if (ok) {\n                long num = 0;\n                foreach (int d in digits) num = num * 10 + d;\n                sum += num;\n            }\n        } while (Library.Permute(digits));\n\n        return sum;\n    }\n}\n"
    },
    {
      "filename": "Problem044.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 44: Pentagon numbers.\n/// Finds the pair of pentagonal numbers Pj and Pk for which their sum and difference are pentagonal and D = |Pk - Pj| is minimised.\n/// </summary>\npublic class Problem044 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 44: Pentagon numbers.\n    /// </summary>\n    /// <returns>The minimised difference D.</returns>\n    public override object Solve() {\n        return MinimalPentagonalDifference();\n    }\n\n    /// <summary>\n    /// Finds minimal difference.\n    /// </summary>\n    private int MinimalPentagonalDifference() {\n        int i = 1;\n        while (true) {\n            i++;\n            int pi = i * (3 * i - 1) / 2;\n            \n            for (int j = i - 1; j > 0; j--) {\n                int pj = j * (3 * j - 1) / 2;\n                \n                if (Library.IsPentagonal(pi - pj) && Library.IsPentagonal(pi + pj)) {\n                    return pi - pj;\n                }\n            }\n        }\n    }\n}\n"
    },
    {
      "filename": "Problem045.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 45: Triangular, pentagonal, and hexagonal.\n/// Finds the next triangle number that is also pentagonal and hexagonal.\n/// </summary>\npublic class Problem045 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 45: Triangular, pentagonal, and hexagonal.\n    /// </summary>\n    /// <returns>The next triangle number after 40755.</returns>\n    public override object Solve() {\n        return NextTriPentHex();\n    }\n\n    /// <summary>\n    /// Finds next number.\n    /// </summary>\n    private long NextTriPentHex() {\n        long n = 144;\n        while (true) {\n            long h = n * (2 * n - 1);\n            if (Library.IsPentagonal(h)) {\n                return h;\n            }\n            n++;\n        }\n    }\n}\n"
    },
    {
      "filename": "Problem046.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 46: Goldbach's other conjecture.\n/// Finds the smallest odd composite that cannot be written as the sum of a prime and twice a square.\n/// </summary>\npublic class Problem046 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 46: Goldbach's other conjecture.\n    /// </summary>\n    /// <returns>The smallest counter-example.</returns>\n    public override object Solve() {\n        return SmallestCounterExample();\n    }\n\n    /// <summary>\n    /// Finds counter-example.\n    /// </summary>\n    private int SmallestCounterExample() {\n        int n = 9; \n        while (true) {\n            if (Library.IsPrime(n)) {\n                n += 2;\n                continue;\n            }\n\n            bool found = false;\n            for (int s = 1; 2 * s * s < n; s++) {\n                int p = n - 2 * s * s;\n                if (Library.IsPrime(p)) {\n                    found = true;\n                    break;\n                }\n            }\n\n            if (!found) return n;\n            n += 2;\n        }\n    }\n}\n"
    },
    {
      "filename": "Problem047.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 47: Distinct primes factors.\n/// Finds the first four consecutive integers to have four distinct prime factors each.\n/// </summary>\npublic class Problem047 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 47: Distinct primes factors.\n    /// </summary>\n    /// <returns>The first of the four consecutive integers.</returns>\n    public override object Solve() {\n        return FirstConsecutiveIntegers(4);\n    }\n\n    /// <summary>\n    /// Finds consecutive integers with n distinct prime factors.\n    /// </summary>\n    private int FirstConsecutiveIntegers(int target) {\n        int consecutive = 0;\n        int i = 2;\n        while (true) {\n            if (CountDistinctPrimeFactors(i) == target) {\n                consecutive++;\n                if (consecutive == target) {\n                    return i - target + 1;\n                }\n            } else {\n                consecutive = 0;\n            }\n            i++;\n        }\n    }\n\n    /// <summary>\n    /// Counts distinct prime factors.\n    /// </summary>\n    private int CountDistinctPrimeFactors(int n) {\n        int count = 0;\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                count++;\n                while (n % i == 0) n /= i;\n            }\n        }\n        if (n > 1) count++;\n        return count;\n    }\n}\n"
    },
    {
      "filename": "Problem048.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "using System.Numerics;\n\nnamespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 48: Self powers.\n/// Finds the last ten digits of the series, 1^1 + 2^2 + 3^3 + ... + 1000^1000.\n/// </summary>\npublic class Problem048 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 48: Self powers.\n    /// </summary>\n    /// <returns>The last ten digits of the series.</returns>\n    public override object Solve() {\n        return LastTenDigitsOfSeries(1000);\n    }\n\n    /// <summary>\n    /// Calculates last 10 digits of series.\n    /// </summary>\n    private long LastTenDigitsOfSeries(int limit) {\n        long modulus = 10000000000;\n        long sum = 0;\n\n        for (int i = 1; i <= limit; i++) {\n            sum = (sum + ModPow(i, i, modulus)) % modulus;\n        }\n        return sum;\n    }\n\n    /// <summary>\n    /// Modular exponentiation for long.\n    /// </summary>\n    private long ModPow(long b, int e, long m) {\n        long result = 1;\n        b %= m;\n        while (e > 0) {\n            if (e % 2 == 1) result = (result * b) % m;\n            e >>= 1;\n            b = (b * b) % m;\n        }\n        return result;\n    }\n}\n"
    },
    {
      "filename": "Problem049.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "namespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 49: Prime permutations.\n/// Finds the other 4-digit increasing sequence.\n/// </summary>\npublic class Problem049 : Problem {\n    /// <summary>\n    /// Solves Project Euler Problem 49: Prime permutations.\n    /// </summary>\n    /// <returns>The 12-digit number formed by concatenating the three terms.</returns>\n    public override object Solve() {\n        return FindOtherSequence();\n    }\n\n    /// <summary>\n    /// Finds sequence.\n    /// </summary>\n    private string FindOtherSequence() {\n        var isPrime = Library.SieveOfEratosthenesBoolArray(10000);\n\n        for (int i = 1000; i < 10000; i++) {\n            if (!isPrime[i]) continue;\n            if (i == 1487) continue; \n\n            int j = i + 3330;\n            int k = j + 3330;\n\n            if (k < 10000 && isPrime[j] && isPrime[k]) {\n                if (ArePermutations(i, j) && ArePermutations(i, k)) {\n                    return $\"{i}{j}{k}\";\n                }\n            }\n        }\n        return \"\";\n    }\n\n    /// <summary>\n    /// Checks if a and b are permutations.\n    /// </summary>\n    private bool ArePermutations(int a, int b) {\n        char[] ca = a.ToString().ToCharArray();\n        char[] cb = b.ToString().ToCharArray();\n        Array.Sort(ca);\n        Array.Sort(cb);\n        return new string(ca) == new string(cb);\n    }\n}\n"
    },
    {
      "filename": "Problem050.cs",
      "language": "C#",
      "notes": "Added XML documentation.",
      "annotated_code": "using System.Collections;\n\nnamespace Project_Euler;\n\n/// <summary>\n/// Solves Project Euler Problem 50: Consecutive prime sum.\n/// Finds which prime, below one million, can be written as the sum of the most consecutive primes.\n/// </summary>\npublic class Problem050 : Problem {\n    private const int Limit = 1000000;\n    private readonly BitArray _isPrime;\n\n    /// <summary>\n    /// Initializes a new instance of the <see cref=\"Problem050\"/> class.\n    /// </summary>\n    public Problem050() {\n        _isPrime = Library.SieveOfEratosthenesBitArray(Limit);\n    }\n\n    /// <summary>\n    /// Solves Project Euler Problem 50: Consecutive prime sum.\n    /// </summary>\n    /// <returns>The prime sum of the most consecutive primes.</returns>\n    public override object Solve() {\n        return LongestConsecutivePrimeSum();\n    }\n\n    /// <summary>\n    /// Finds longest consecutive prime sum.\n    /// </summary>\n    private int LongestConsecutivePrimeSum() {\n        var primes = Library.SievePrimesList(Limit);\n        int maxLen = 0;\n        int maxPrime = 0;\n\n        long[] primeSum = new long[primes.Count + 1];\n        primeSum[0] = 0;\n        for (int i = 0; i < primes.Count; i++) {\n            primeSum[i + 1] = primeSum[i] + primes[i];\n        }\n\n        for (int i = 0; i < primes.Count; i++) {\n            for (int j = i - (maxLen + 1); j >= 0; j--) {\n                long currentSum = primeSum[i + 1] - primeSum[j];\n                if (currentSum >= Limit) break;\n\n                if (_isPrime[(int)currentSum]) {\n                    if (i - j + 1 > maxLen) {\n                        maxLen = i - j + 1;\n                        maxPrime = (int)currentSum;\n                    }\n                }\n            }\n        }\n        return maxPrime;\n    }\n}\n"
    }
  ],
  "README": {
    "status": "updated",
    "notes": "Expanded architecture and usage sections.",
    "content": "# Project Euler C# Solver\n\nThis repository contains a C# solution framework for solving and benchmarking problems from [Project Euler](https://projecteuler.net/). It is designed to be efficient, extensible, and easy to navigate, with a focus on clean code and performance analysis.\n\n## Architecture\n\nThe project is structured around a central `Problem` base class, allowing for a consistent interface to solve and benchmark any implemented problem.\n\n### Key Components\n\n*   **`Problem` / `Problem<T>`**: The abstract base classes that all problem solutions inherit from. They define the `Solve()` contract.\n*   **`ProblemFactory`**: A static factory that manages the registration and instantiation of problem classes. It uses explicit registration for type safety and performance.\n*   **`ProblemSolver`**: The core engine that runs problems. It handles individual execution and full benchmarking suites, collecting timing data.\n*   **`Library`**: A comprehensive utility class containing reusable mathematical functions (primes, GCD, permutations, combinatorics) and helper methods used across multiple problems.\n*   **`BenchmarkRunner`**: Provides advanced statistical analysis of problem performance, including mean execution time, standard deviation, and confidence intervals.\n*   **`SolutionVerifier`**: Validates the output of `Solve()` methods against a set of known correct answers (`known_answers.json`), ensuring correctness after code refactoring or optimization.\n*   **`Configuration`**: A singleton manager for application settings, including logging levels and benchmark parameters, loaded from `euler_config.json`.\n*   **`MemoryEfficientCache`**: specialized caching implementations for memory-intensive operations (e.g., bit arrays for prime sieves, sparse dictionaries for Collatz sequences).\n\n### Workflows\n\n1.  **Solving Problems**: Users interact with the console menu (`Program.cs`) to solve a specific problem or all problems.\n2.  **Benchmarking**: The `ProblemSolver` executes problems multiple times to gather stable timing metrics, which are then processed by `OutputHandler` to generate reports.\n3.  **Reporting**: Results are output to the console, a text log (`log.txt`), a raw JSON data file (`benchmark.json`), and an interactive HTML report (`benchmark.html`).\n\n## Getting Started\n\n### Prerequisites\n\n*   .NET SDK 8.0 or higher.\n\n### Building and Running\n\n1.  **Build** the solution from the root directory:\n    ```bash\n    dotnet build src/ProjectEuler/ProjectEuler.csproj\n    ```\n\n2.  **Run** the application:\n    ```bash\n    dotnet run --project src/ProjectEuler/ProjectEuler.csproj\n    ```\n\n## Usage\n\nUpon launching, the interactive menu offers the following options:\n\n*   **Enter 'a'**: Solves all registered problems, runs the benchmark suite, and generates full reports.\n*   **Enter 't'**: Verifies all currently implemented solutions against known correct answers.\n*   **Enter Problem Number (e.g., '1', '50')**: Solves the specified problem and displays the result and execution time.\n\n## Adding a New Solution\n\n1.  Create a new class file (e.g., `Problem051.cs`) inheriting from `Problem`.\n2.  Implement the `Solve()` method with your logic.\n3.  Register the new class in `ProblemFactory.cs` inside the `InitializeProblemRegistry` method.\n4.  (Optional) Add the known correct answer to `SolutionVerifier.cs` or `known_answers.json` for verification.\n\n## Documentation\n\nThe codebase is fully documented with XML docstrings.\n*   **Core Logic**: See `Library.cs` for math utilities.\n*   **Problem Solutions**: Each `ProblemXXX.cs` file contains logic specific to that problem.\n"
  },
  "self_review": "Comprehensive XML documentation added to all core and problem files. Logic preserved exactly as found in the repository state. README updated to reflect the modular architecture."
}