namespace Project_Euler;

/// <summary>
/// Solves Project Euler Problem 27: Quadratic primes.
/// Finds the product of the coefficients, a and b, for the quadratic expression n² + an + b
/// that produces the maximum number of primes for consecutive values of n, starting with n=0.
/// Constraints: |a| < 1000 and |b| <= 1000.
/// Further details can be found at https://projecteuler.net/problem=27
/// </summary>
public class Problem027 : Problem {
    /// <summary>
    /// Defines the search range for coefficients 'a' and 'b'.
    /// |a| < Limit and |b| < Limit (actually |b| <= Limit as per problem, but loop goes b < limit).
    /// For this problem, Limit is 1000.
    /// </summary>
    private const int Limit = 1000;

    /// <summary>
    /// The upper bound for the Sieve of Eratosthenes used to pre-compute primes.
    /// This limit is chosen to safely cover:
    /// 1. Values of 'b' (which must be prime, so b < 1000).
    /// 2. Values generated by the quadratic formula n² + an + b.
    ///    With |a|<1000, |b|<=1000, and n typically found to be < 100 for optimal solutions,
    ///    n² + an + b could be roughly 80² + 1000*80 + 1000 ≈ 87400.
    ///    A SieveLimit of 100,000 provides a safe margin.
    /// </summary>
    private const int SieveLimit = 100000;

    /// <summary>
    /// Boolean array storing pre-computed primes up to <see cref="SieveLimit"/>.
    /// `_isPrime[k]` is true if k is prime, false otherwise.
    /// Populated by the Sieve of Eratosthenes algorithm in the constructor.
    /// </summary>
    private readonly bool[] _isPrime;

    /// <summary>
    /// Initializes a new instance of the <see cref="Problem027"/> class.
    /// This constructor pre-computes primes up to <see cref="SieveLimit"/> using
    /// <see cref="Library.SieveOfEratosthenesBoolArray"/> and stores them in the
    /// <see cref="_isPrime"/> array for efficient primality testing.
    /// </summary>
    public Problem027() {
        _isPrime = Library.SieveOfEratosthenesBoolArray(SieveLimit);
    }

    /// <summary>
    /// Calculates the solution for Project Euler Problem 27.
    /// It searches for the quadratic formula n² + an + b (within |a| &lt; 1000, |b| &lt;= 1000)
    /// that produces the maximum number of consecutive primes for n starting from 0,
    /// and returns the product of coefficients a and b.
    /// </summary>
    /// <returns>The product of the coefficients a and b for the optimal quadratic formula.</returns>
    public override object Solve() {
        return CoefficientProduct(Limit);
    }

    /// <summary>
    /// Finds the product of coefficients 'a' and 'b' for the quadratic expression n² + an + b
    /// that produces the maximum number of primes for consecutive values of n, starting from n=0.
    /// The search is constrained by |a| &lt; <paramref name="coeffLimit"/> and |b| &lt; <paramref name="coeffLimit"/>.
    /// Optimizations:
    /// - For n=0, n² + an + b = b. So, 'b' must be a prime number.
    /// - Since 'b' must be prime, it's positive. Loop for 'b' starts from 3 and increments by 2 (only odd primes, 2 is not considered as it leads to fewer primes).
    /// - For n=1, n² + an + b = 1 + a + b. If 'b' is an odd prime:
    ///   - If 'a' is even, 1 + a + b = 1 + even + odd = even. For this to be prime, it must be 2.
    ///     1 + a + b = 2 => a + b = 1. This limits 'a' significantly.
    ///   - If 'a' is odd, 1 + a + b = 1 + odd + odd = odd. This is more likely to be prime for longer sequences.
    ///   The code iterates 'a' starting from -coeffLimit + 1 (an odd number if coeffLimit is even like 1000) and increments by 2, ensuring 'a' is always odd.
    /// </summary>
    /// <param name="coeffLimit">The exclusive upper limit for the absolute values of coefficients 'a' and 'b'.</param>
    /// <returns>The product of the coefficients 'a' and 'b' that yield the longest sequence of primes.</returns>
    private int CoefficientProduct(int coeffLimit) {
        int bestA = 0, bestB = 0, maxLength = 0;

        // Iterate 'b' from 3 up to coeffLimit-1. 'b' must be prime.
        // Only odd primes are considered for b, as b=2 with an odd 'a' makes 1+a+b even.
        for (int b = 3; b < coeffLimit; b += 2) {
            if (b >= _isPrime.Length || !_isPrime[b]) { // Ensure b is within sieve bounds and prime
                continue;
            }

            // Iterate 'a' from -coeffLimit+1 up to coeffLimit-1.
            // Start a at an odd value (if coeffLimit is 1000, -999) and increment by 2, so 'a' is always odd.
            // This is an optimization because if 'a' were even (and 'b' is an odd prime), then for odd 'n',
            // n*n (odd) + a*n (even) + b (odd) = even. If this value > 2, it's not prime.
            for (int a = -coeffLimit + 1; a < coeffLimit; a += 2) {
                int n = 0;
                while (true) {
                    int val = n * n + a * n + b;
                    // Check if 'val' is positive, within sieve bounds, and prime.
                    if (val < 0 || val >= SieveLimit || !_isPrime[val]) {
                        break; // End of prime sequence for this (a,b)
                    }
                    n++; // Increment count of consecutive primes
                }

                if (n > maxLength) { // If current sequence is longer than best found so far
                    maxLength = n;
                    bestA = a;
                    bestB = b;
                }
            }
        }
        return bestA * bestB;
    }
}