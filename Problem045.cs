namespace Project_Euler;

/// <summary>
/// Solves Project Euler Problem 45: Triangular, pentagonal, and hexagonal.
/// Triangle, pentagonal, and hexagonal numbers are generated by the formulae:
/// Triangle    T_n = n(n+1)/2     1, 3, 6, 10, 15, ...
/// Pentagonal  P_n = n(3n−1)/2    1, 5, 12, 22, 35, ...
/// Hexagonal   H_n = n(2n−1)      1, 6, 15, 28, 45, ...
/// It is found that T_285 = P_165 = H_143 = 40755.
/// The problem asks to find the next triangle number that is also pentagonal and hexagonal.
/// Further details can be found at https://projecteuler.net/problem=45
/// </summary>
public class Problem045 : Problem {
    /// <summary>
    /// Calculates the solution for Project Euler Problem 45.
    /// It finds the next number after H_143 (40755) that is simultaneously triangular,
    /// pentagonal, and hexagonal.
    /// </summary>
    /// <returns>The next triangular, pentagonal, and hexagonal number after 40755.</returns>
    public override object Solve() {
        // H_143 is 40755. We are looking for the next such number.
        // The input to FindNextTphNumber is the index of the hexagonal number to start searching after.
        return FindNextTphNumber(143);
    }

    /// <summary>
    /// Finds the next number that is triangular, pentagonal, and hexagonal (TPH),
    /// starting the search after the hexagonal number H_<paramref name="previousHexagonalIndex"/>.
    ///
    /// Intended Algorithm:
    /// All hexagonal numbers H_i are also triangular numbers T_{2i-1}.
    /// So, the method can iterate through hexagonal numbers H_i (for i > <paramref name="previousHexagonalIndex"/>)
    /// and for each, check if it is also a pentagonal number using <see cref="Library.IsPentagon(long)"/>.
    /// The first such number found is the solution.
    ///
    /// Current State & Workaround:
    /// - The call to `Library.IsPentagon(hex)` is currently commented out with a TODO note,
    ///   indicating a potential environment issue or an incomplete implementation of that library function.
    /// - A dummy condition (`iterations > 10`) and a placeholder return (`return hex;`) have been
    ///   added to make the method syntactically valid and terminate.
    /// - **Due to this workaround, the method in its current state does NOT correctly find the next TPH number.**
    ///   It will return a hexagonal number after a fixed number of iterations.
    /// </summary>
    /// <param name="previousHexagonalIndex">The index 'n' of the hexagonal number H_n from which to start searching for the *next* TPH number.
    /// For example, if H_143 is known, pass 143 to find the next one (starting check from H_144).</param>
    /// <returns>
    /// Intended: The next number that is triangular, pentagonal, and hexagonal.
    /// Current (with workaround): A hexagonal number after a limited number of iterations.
    /// </returns>
    private long FindNextTphNumber(int previousHexagonalIndex) {
        long currentHexagonalIndex = (long)previousHexagonalIndex + 1;

        while (true) {
            // Calculate the hexagonal number H_i = i(2i-1)
            long currentHexagonalValue = currentHexagonalIndex * (2L * currentHexagonalIndex - 1);

            if (IsPentagonal(currentHexagonalValue)) {
                return currentHexagonalValue;
            }
            
            currentHexagonalIndex++;
        }
    }

    private bool IsPentagonal(long n) {
        if (n <= 0) return false;
        long val = 1 + 24 * n;
        long sqrt = (long)Math.Sqrt(val);
        return sqrt * sqrt == val && (sqrt + 1) % 6 == 0;
    }
}
