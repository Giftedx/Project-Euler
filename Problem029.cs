namespace Project_Euler;

/// <summary>
/// Solves Project Euler Problem 29: Distinct powers.
/// Calculates how many distinct terms are in the sequence generated by a^b
/// for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100.
/// Further details can be found at https://projecteuler.net/problem=29
/// </summary>
public class Problem029 : Problem {
    /// <summary>
    /// Calculates the solution for Project Euler Problem 29.
    /// It determines the number of distinct terms generated by a^b for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100.
    /// </summary>
    /// <returns>The number of distinct terms in the sequence.</returns>
    public override object Solve() {
        return DistinctPowers();
    }

    /// <summary>
    /// Calculates the number of distinct terms in the sequence generated by a^b
    /// for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100.
    ///
    /// **Warning: The implementation below is highly unconventional and appears to use a pattern-based
    /// or pre-calculated counting method rather than direct computation and storage of powers (e.g., in a HashSet).
    /// The mathematical basis for the constants and conditional logic is not immediately evident from the code itself.
    /// Documenting the precise step-by-step mathematical justification is not possible without further
    /// information on the specific algorithm or theorem being implemented. This makes the code difficult
    /// to verify or maintain.**
    ///
    /// The method seems to sum up counts based on categories or properties of numbers, potentially related to
    /// how powers overlap (e.g., 4^b = (2^2)^b = 2^(2b)).
    /// The variables `noSquare`, `noThird`, `thirdPowers`, `fourthPowers`, etc., suggest a classification
    /// of numbers or powers to avoid overcounting.
    /// </summary>
    /// <returns>The count of distinct terms a^b in the specified range.</returns>
    private long DistinctPowers() {
        long result = 0;

        // Constant values - their derivation is not clear from the code.
        // `noSquare` might relate to perfect squares (a = k^2) and how their powers might overlap with powers of k.
        // `noThird` might relate to perfect cubes or similar.
        const int noSquare = 81 * 99; // 81 = 3^4 or 9^2. 99 is the number of exponents (2 to 100).
        const int noThird = 4 * (99 + 50); // Meaning of 4, 99, 50 here is unclear without context.

        // Variables to count specific categories of powers.
        // The loops iterate i from 2 to 100 (likely representing the base 'a' or a factor of 'a').
        // The conditions inside the if statements (e.g., n > 100, n > 200 || n % 2 != 0) are obscure
        // and likely relate to specific counting adjustments for overlaps.
        int thirdPowers = 0;  // Possibly related to a = k^x where b*x results in a multiple of 3 for the exponent.
        int fourthPowers = 0; // Similar, but for multiples of 4.
        int fifthPowers = 0;
        int sixthPowers = 0;

        for (int i = 2; i <= 100; i++) {
            // This section appears to be counting how many powers (like i*3, i*4, etc.)
            // satisfy certain complex conditions. These 'n' values likely represent exponents.
            // The conditions (e.g., n > 200 || n % 2 != 0) are specific rules for this counting method.

            int n = i * 3; // Potential resulting exponent if base was x^i and power was 3, or base x and power 3i.
            if (n > 100 && // Exponent > 100
                (n > 200 || n % 2 != 0)) // Obscure condition
                thirdPowers++;

            n = i * 4;
            if (n > 200 &&
                (n > 300 || n % 3 != 0))
                fourthPowers++;

            n = i * 5;
            if (n > 100 &&
                (n > 200 || n % 2 != 0) &&
                (n > 300 || n % 3 != 0) &&
                (n > 400 || n % 4 != 0))
                fifthPowers++;

            n = i * 6;
            if (n > 100 &&
                (n > 200 || n % 2 != 0) &&
                (n > 300 || n % 3 != 0) &&
                (n > 400 || n % 4 != 0) &&
                (n > 500 || n % 5 != 0))
                sixthPowers++;
        }

        // The final result is an aggregation of these counts and constants.
        // The structure `99 + 50 + ...` suggests base counts for certain types of numbers.
        // 99 is the count of possible 'a' values (2 to 100) and 'b' values (2 to 100).
        // (100-2+1) = 99.
        // The total number of pairs (a,b) is 99*99 = 9801. This is the maximum possible distinct terms.
        // The formula below is evidently a way to subtract or adjust for overlaps.

        // It's highly probable that this code is a direct translation of a specific mathematical formula
        // or counting argument derived from number theory for this exact problem (a,b in [2,100]).
        // Without that external reference, a full, confident explanation of each term is not feasible.

        // First part of the sum. The terms 99 and 50 are repeated.
        // 99 = number of choices for base `a` (or exponent `b`).
        // 50 = 100/2, possibly related to powers of 2 or square roots.
        result += 99 + 50 + thirdPowers + fourthPowers + noSquare + noThird;

        // Second part of the sum, adding more calculated counts.
        result += 99 + 50 + thirdPowers + fourthPowers + fifthPowers + sixthPowers;

        // The problem's answer is 9183.
        // A standard solution yields:
        // Total possible terms = 99 * 99 = 9801.
        // The code calculates a value based on these obscure counts.
        // If this code produces 9183, it is through a non-obvious counting method.
        // Let's assume the standard result is what's expected for typical solutions.
        // The current code yields:
        // noSquare = 81 * 99 = 8019
        // noThird = 4 * (99 + 50) = 4 * 149 = 596
        // The loops for thirdPowers etc. would need to be run to get their values.
        // This is not a standard approach and is very hard to interpret.
        // A typical approach would be:
        // HashSet<BigInteger> distinctTerms = new HashSet<BigInteger>();
        // for a = 2 to 100:
        //   for b = 2 to 100:
        //     distinctTerms.Add(BigInteger.Pow(a, b));
        // return distinctTerms.Count;
        // This method is likely attempting to achieve that count without large number arithmetic or storage.

        return result; // The result from this specific, opaque algorithm.
    }
}